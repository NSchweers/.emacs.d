# -*- coding: utf-8; -*-
#+PROPERTY: header-args :tangle literate-init.el
#+PROPERTY: header-args+ :comments link
#+PROPERTY: header-args+ :shebang ;; -*- lexical-binding: t-*-

#+TITLE: An Emacs Configuration
#+AUTHOR: Nathanael Schweers

* Workaround for a security bug
#+BEGIN_SRC elisp
  ;; Mitigate Bug#28350 (security) in Emacs 25.2 and earlier.
  (eval-after-load "enriched"
    '(defun enriched-decode-display-prop (start end &optional param)
       (list start end)))
#+END_SRC
* Early setup
Some things just have to happen really early.
** Activate lexical scope
As Emacs started out without lexical scope, it has to be enabled by the
programmer on a per-buffer basis.  The whole file gets a shebang argument via a
property line (see the beginning of the Org file).

** No splash screen
#+BEGIN_SRC elisp
  (setf inhibit-startup-message t)
#+END_SRC

** Don’t load old .elc files
For some reason the default in Emacs is or was to load outdated bytecode files.

#+BEGIN_SRC elisp
  (setf load-prefer-newer t)
#+END_SRC

** Install =use-package= if necessary
At this point we have not yet loaded anything into emacs, hence =use-package= is
not yet loaded, possibly not even installed.  To rectify this situation, as
first we need to set up the packages system.
*** Initialize the package system
    We have to initialize the package system before using it, so we do that here.

    We have to =require= the package system, as it is not loaded by default.

    #+BEGIN_SRC elisp
      (require 'package)
    #+END_SRC
**** Add melpa and melpa-stable repositories
     I use an alist of repositories (currently only two) which are added to the
     package archives unless they are already present.
    #+BEGIN_SRC elisp
      ;; Add melpa to package repos
      (dolist (m '(("melpa-stable" . "http://stable.melpa.org/packages/")
                   ("melpa" . "http://melpa.org/packages/")))
        (add-to-list 'package-archives m t))
    #+END_SRC
**** Add Org Mode repo
     Not only do we want to add the repository, we also want to append it (at
     least that’s what the [[http://orgmode.org/elpa.html][website]] says).

     #+BEGIN_SRC elisp
       (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
     #+END_SRC
*** Initialize
    As soon as the archives have been added, the package system can be initialized.
    As a poor man’s check, I look for a file named after one of the archives.  If it
    doesn’t (yet) exist, the archives have to be fetched.

    #+BEGIN_SRC elisp
      (package-initialize)

      (unless (file-exists-p (expand-file-name
                              "elpa/archives/melpa"
                              user-emacs-directory))
        (package-refresh-contents))
    #+END_SRC

    I used to have a whole lot more code, which can be found in the [[file:code/setup-package.el][original file]].
    I hope this is no longer needed.  I never really liked having it, but is was
    once necessary.
*** Setup =use-package=
    Now that the package system is set up, I can install =use-package=.

    #+BEGIN_SRC elisp
      (unless (package-installed-p 'use-package)
        (package-install 'use-package))
    #+END_SRC

    Last but not least I want =use-package= to automatically install missing
    packages and be verbose about what it’s doing.  As I don’t want to pass an
    extra option to every single invocation, I’ll add it as a default here.

    #+BEGIN_SRC elisp
      (setf use-package-always-ensure t
            use-package-verbose t)
    #+END_SRC
** Add site-lisp to load path
The directory site-lisp is not by default part of the load-path.  Also add mu4e
to the load path explicitly.

#+BEGIN_SRC elisp
  (add-to-list 'load-path (expand-file-name "site-lisp" user-emacs-directory))
  ;; (add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")
#+END_SRC

** Add debian specific stuff
If I’m on debian, I want debian-el.  The problem is that its not included in
melpa, so I have to install it via package manager.

I first want to check if I’m on Unix, then if I’m on debian.

#+BEGIN_SRC elisp
  (defun on-unix? ()
    (not (memq system-type '(ms-dos windows-nt))))

  (defun on-debian? ()
    (when (and (on-unix?)
               (file-exists-p "/etc/os-release"))
      (with-temp-buffer
        (insert-file-contents "/etc/os-release")
        (goto-char 1)
        (search-forward-regexp "^ID=")
        (looking-at-p "debian$"))))

#+END_SRC

Now that I can check whether or not I’m on debian, I want to check whether or
not =debian-el= is installed.

#+BEGIN_SRC elisp
  (defun debian-el-installed? ()
    (with-temp-buffer
      (call-process "/usr/bin/aptitude" nil t nil
                    "search" "?installed(^debian-el$)")
      (goto-char (point-min))
      (looking-at-p "^i")))

#+END_SRC

Now that we can check that, we check whether it is installed and then add the
appropriate directory to the load path.

#+BEGIN_SRC elisp
  (when (and (on-debian?)
             (debian-el-installed?))
    (add-to-list 'load-path "/usr/share/emacs/site-lisp/debian-el" t))
#+END_SRC

Now we can finally =require= =debian-el=!

#+BEGIN_SRC elisp
  (when (and (on-debian?)
             (debian-el-installed?))
    (require 'debian-el))
#+END_SRC
* Set up the appearance of Emacs
We set up the appearance very early on so the display doesn’t behave too badly.
Unfortunately it still flickers and bugs around a little.
** Remove the GUI elements we don’t like
First, we remove the toolbar, as no sane person should be using it in Emacs.
Well, no sane person using Emacs a /lot/ should use it.

#+BEGIN_SRC elisp
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
#+END_SRC

#+BEGIN_SRC elisp
  (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
#+END_SRC

** Highlight parentheses
When point is on a parenthesis, we want to highlight the matching paren.

#+BEGIN_SRC elisp
  (show-paren-mode 1)
#+END_SRC

** Font size
I don’t want a huge font.  As I want to be able to change the font size while
running Emacs, and I want to be able to return to /my/ default size, I record
that in a variable.  Then the variable is used to set the fontsize.

#+BEGIN_SRC elisp
(defvar schweers/default-font-height 80)
(set-face-attribute 'default nil :height schweers/default-font-height)
#+END_SRC
** Global font locking
   :PROPERTIES:
   :header-args: :tangle no
   :END:
Normally, Emacs enables font locking by default.  The code is still here, but it
won’t be tangled.

#+BEGIN_SRC elisp
  (global-font-lock-mode t)
#+END_SRC

** Scrollbar on the right
For some reason the default in Emacs is not to put the scrollbar on the right.
As this only works in window systems, we have to check for that too.

#+BEGIN_SRC elisp
  (when window-system
    (set-scroll-bar-mode 'right))
#+END_SRC

** Line and column numbers
Always show both line /and/ column numbers in the modeline.

#+BEGIN_SRC elisp
  (column-number-mode 1)
  (line-number-mode 1)
#+END_SRC

** Show empty lines after buffer end.
I want to see empty lines at the end of the buffer.

#+BEGIN_SRC elisp
  (set-default 'indicate-empty-lines t)
#+END_SRC

** Mouse support in xterm
When we have a terminal session, but it’s in an xterm, we can still use the
mouse.  But, we have to activate it.

#+BEGIN_SRC elisp
  (xterm-mouse-mode 1)
#+END_SRC

** Maximize the current frame
Unfortunately this doesn’t work terribly well.  I’m not sure if there is a
better way to do this.  I especially would like to not touch the windows system,
as there are too many, and some of them are just plain weird.

#+BEGIN_SRC elisp
  (when window-system
    (set-frame-parameter nil 'fullscreen 'maximized))
#+END_SRC

** Disable cursor blinking
This too also only works when using a window system.  On the other hand, it’s
not needed on a terminal.

#+BEGIN_SRC elisp
  (when window-system
    (blink-cursor-mode -1))
#+END_SRC

** Disable beeping
Don’t ever beep.  I’d rather have a flashing screen.

#+BEGIN_SRC elisp
  (setf visible-bell t)
#+END_SRC

** Set the region color
As my second screen isn’t in a terribly good shape, the default region color is
barely readable.  Normally I’d use customize, but the customize facility thinks
(or used to think) that Emacs is running with -q, even when it isn’t.

#+BEGIN_SRC elisp
  (face-spec-set 'region
                 '((t (:distant-foreground "royal blue"
                                           :background "cornflower blue"))))
#+END_SRC

** Change the threshold for vertical or horizontal split
As I generally prefer putting windows next to each other rather than stacking
them, I changed the threshold.

#+BEGIN_SRC elisp
  (setf split-height-threshold 180)
#+END_SRC
* Set up some more sane defaults
Emacs is full of variables etc. which have defaults which are highly outdated.
This is the reason for the proliferation of so many Emacs starter kits.

While my visual settings may also fall into this category, I wanted to separate
them for technical reasons: I want the visual settings to be activated before
doing the heavy lifting, as much of the loading I do is quite time-consuming.
** Make script files executable on save
If a file starts with #! the file should gain the executable bit.
#+BEGIN_SRC elisp
  (add-hook
   'after-save-hook
   'executable-make-buffer-file-executable-if-script-p)
#+END_SRC
** Cleanup whitespace on save
Any trailing whitespace on a line, or empty lines at the beginning or end of a
buffer should be stripped before saving.
#+BEGIN_SRC elisp
  (add-hook 'before-save-hook #'whitespace-cleanup)
#+END_SRC
** Show trailing whitespace
   :PROPERTIES:
   :header-args: :tangle no
   :END:
Emacs can show trailing whitespace, but I don’t want it to go overboard with it.

#+BEGIN_SRC elisp
  (setf whitespace-style '(face trailing lines indentation indentation::space))
  (global-whitespace-mode 1)
#+END_SRC
*** Disable whitespace mode for Org Mode buffers
Org Mode often shows long text in a shorter fashion (e.g. links) and sometimes
even requires long lines because of its syntax.

Sadly, this does not work.
#+BEGIN_SRC elisp
  (add-hook 'org-mode-hook (lambda () (whitespace-mode -1)) t)
#+END_SRC
** Set a proper place for =custom.el=
By default Emacs still uses the home directory of the user directly.  This is a
quite sad relic of the old days on UNIX.  Nowadays one should put all Emacs
related files into a directory and make said directory a git (or hg, or
whatever) repository.  A consequence of this policy is that Emacs places its
customize settings directly into =user-init-file=.  The variable =custom-file=
holds the place to use.  After setting the place, the file is loaded.

#+BEGIN_SRC elisp
  (setf custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file)
#+END_SRC

Possibly I should stop using customize altogether.

** Place backups at a sane position
Backup files should be written to a separate directory, as to not annoy other
users who may browse the same tree.  This is particularly true of mounted
network shares.  Luckily, the widespread use of version control pretty much
makes this a non-issue.  Still, it may be useful for TRAMP.

The second line makes sure that backup files are even created when Emacs thinks
we’re using version control.  Note that I don’t ever use =vc-mode=, as =magit=
is the best interface to git there ever was, and git can interface with most
other systems, to make them more usable and sane (I’m looking at you SVN)!

#+BEGIN_SRC elisp
  (setf backup-directory-alist
        `(("." . ,(expand-file-name "backups" user-emacs-directory)))
        vc-make-backup-files t)
#+END_SRC

** Save where point is/was in a visited file
Emacs can keep track of where point last was in a file.  The data
needed for this is saved in a file.  The name for this file can be
found in the variable =save-place-file=.  Sadly, debian broke emacs in
stretch, so I have to use this ancient emacs24.5 like some cretin

#+BEGIN_SRC elisp
  (unless (version<= emacs-version "25.0")
    (setf save-place-file (expand-file-name ".places" user-emacs-directory))
    (if (version< emacs-version "25.1")
        (progn
          (require 'saveplace)
          (setq-default save-place t))
      (save-place-mode 1)))
#+END_SRC

** Echo keystrokes
Normally Emacs waites for a while before showing the keys which were pressed, if
the given keys are not sufficient to form a command (i.e. they result in a
keymap).

I want this to happen quickly.

#+BEGIN_SRC elisp
  (setf echo-keystrokes 0.1)
#+END_SRC

** Disable shift-selection
As I use the region the way it’s supposed to be used in Emacs, I don’t need any
shift selection.  Also, it interferes with switching windows using shift with
the arrow keys.  Nevermind that both scenarios are a problem in Org Mode.

#+BEGIN_SRC elisp
  (setf shift-select-mode nil)
#+END_SRC

** Use automatic, transparent compression of files.
Emacs can transparently open compressed files (among other things).  It can also
transparently open encrypted files and archives!  To activate autocompression,
we need to activate a mode.

#+BEGIN_SRC elisp
  (auto-compression-mode 1)
#+END_SRC

** Enable UTF-8 for everything
I’m not entirely sure how this piece of code works, I just scraped it from
Magnar Sveen’s config.

#+BEGIN_SRC elisp
  ;; UTF-8 please
  (setf locale-coding-system 'utf-8)      ;pretty
  (set-terminal-coding-system 'utf-8)     ;pretty
  (set-keyboard-coding-system 'utf-8)     ;pretty
  (set-selection-coding-system 'utf-8)    ;pretty
  (set-language-environment "UTF-8")      ;please
  (prefer-coding-system 'utf-8)           ;with sugar on top
#+END_SRC

** Activate transient mark mode
As any program which is used in the 21st century, Emacs can select text.  Unlike
any other program in this century, it doesn’t do so by default.  At least not in
a way anyone would expect.  To enable this behavior, enable
=transient-mark-mode=.

#+BEGIN_SRC elisp
  (transient-mark-mode 1)
  (make-variable-buffer-local 'transient-mark-mode)
  (put 'transient-mark-mode 'permanent-local t)
  (setq-default transient-mark-mode t)
#+END_SRC

** Delete selected text on backspace or delete
For historic reasons, Emacs does not delete the selected text on backspace or
delete, but deletes one character and disables the region (selection).  To
rectify this, we need another mode.

#+BEGIN_SRC elisp
  (delete-selection-mode 1)
#+END_SRC

** Set the desired line width
Emacs breaks lines at 72 characters, not 80, by default.  This can be changed
with a variable.  Also, there is a global minor mode and a function to do this
as one types.

#+BEGIN_SRC elisp
  (setq-default fill-column 80)
  (setq-default auto-fill-function 'do-auto-fill)
  (auto-fill-mode 1)
#+END_SRC

** Save a list of recent files
Save a list of recently opened files.  This can be accessed via C-x f.  I have
to admit that I have never used this, and helm barfs on buffer history for some
reason.  I’m not sure whether or not this is related.

#+BEGIN_SRC elisp
  (recentf-mode 1)
  (setq recentf-max-saved-items 100) ;; just 20 is too recent
#+END_SRC

** Save minibuffer history
Emacs can also save the history of the minibuffer.  Like, duh!  Again we need a
mode and a variable.

#+BEGIN_SRC elisp
  (savehist-mode 1)
  (setf history-length 1000)
#+END_SRC

** Setup winner mode
I’ve never really gotten around to doing this, but maybe I will some day.  It
seems Emacs can save window configurations and switch between them.  I have no
idea how well this works.  It can be activated by enabling a global minor mode.

#+BEGIN_SRC elisp
  (winner-mode 1)
#+END_SRC

** Never indent tabs
While this tends to break Makefiles, in general one doesn’t want tabs in source
code.  Yes, this is subject to flamewars, but I’ve settled it for myself.

#+BEGIN_SRC elisp
  (set-default 'indent-tabs-mode nil)
#+END_SRC

** Navigate sillycased words with subword mode
Thanks to =global-subword-mode= one can navigate words with weird casing in any
mode!

#+BEGIN_SRC elisp
  (global-subword-mode 1)
#+END_SRC

** Enable recursive minibuffers
Emacs is capable of nesting minibuffers, but as this feature can be very
confusing to newcomers, it is disabled by default.  I want it though.

#+BEGIN_SRC elisp
  (setf enable-recursive-minibuffers t)
  (minibuffer-depth-indicate-mode 1)
#+END_SRC

** Allow for more memory consumption
This may sound wrong, but I want Emacs to be able to use lots of memory.
Garbage collection is a very expensive operation (not in general, but in Emacs),
so I don’t want it to happen too often.  This is why I allow Emacs to allocate
lots of memory.

#+BEGIN_SRC elisp
  (setf gc-cons-threshold 20000000
        gc-cons-percentage 0.3)
#+END_SRC

** Add directory name to non-unique buffer names
Emacs buffers typically only have the name of the file itself as the buffer
name.  When this is not enough, I’d like Emacs to add the directory name to
/both/ buffers in order to make the names unique.  By default Emacs simply adds
a number in angle brackets to the end of the name.  This may work for info
buffers, but not for files in general.

#+BEGIN_SRC elisp
  (with-demoted-errors (require 'uniquify)
                       (setq uniquify-buffer-name-style 'forward))
#+END_SRC

** Make ediff more sane
I’m not sure what exactly this does, but I’ve been using it like this since I’ve
been using it at all, and I like it how it is.  So I’m not changing it.

#+BEGIN_SRC elisp
  (setf ediff-diff-options "-w"
        ediff-split-window-function 'split-window-horizontally
        ediff-window-setup-function 'ediff-setup-windows-plain)

#+END_SRC

** Change =eval-expression-print-level=
Nic says eval-expression-print-level needs to be set to nil (turned off) so that
you can always see what's happening.

#+BEGIN_SRC elisp
  (setf eval-expression-print-level nil)
#+END_SRC

** Sane mouse scrolling
For the longest time Emacs’ scrolling has annoyed me.  It’s even worse that
pointer acceleration on a mouse.  I also scraped this from Magnar Sveen’s
config.

#+BEGIN_SRC elisp
  (setq mouse-wheel-scroll-amount '(5 ((shift) . 5)))

  (setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling

  (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse

  (setq scroll-step 1) ;; keyboard scroll one line at a time

  ;; Have proper scrolling.
  (setf scroll-margin 0
        scroll-conservatively 0
        scroll-up-aggressively 0.01
        scroll-down-aggressively 0.01)
  (setq-default scroll-up-aggressively 0.01
                scroll-down-aggressively 0.01)
#+END_SRC

** Setup diary
** Activate abbrevs
   #+BEGIN_SRC elisp
     (setq abbrev-file-name             ;; tell emacs where to read abbrev
           "~/.emacs.d/abbrev_defs")    ;; definitions from...
     (setq save-abbrevs t)              ;; save abbrevs when files are saved
     ;; you will be asked before the abbreviations are saved
     (setq-default abbrev-mode t)
   #+END_SRC
*** Set diary file to a sane postion
As mentioned elsewhere, Emacs tends to pollute the users home directory.  Here,
diary files are placed into ~/.emacs.d/.

#+BEGIN_SRC elisp
  (setf diary-file "~/.emacs.d/diary")
#+END_SRC
*** Add German holidays
#+BEGIN_SRC elisp
  (add-hook 'calendar-load-hook (lambda () (calendar-set-date-style 'european)))
  (setf solar-n-hemi-seasons '("Frühlingsanfang"
                               "Sommeranfang"
                               "Herbstanfang"
                               "Winteranfang")
        holiday-general-holidays '((holiday-fixed 1 1 "Neujahr")
                                   (holiday-fixed 5 1 "Tag der Arbeit")
                                   (holiday-fixed 10 3
                                                  "Tag der Deutschen Einheit"))
        holiday-christian-holidays '((holiday-fixed 1 6 "Heilige Drei Könige")
                                     (holiday-easter-etc -48 "Rosenmontag")
                                     (holiday-easter-etc -3 "Gründonnerstag")
                                     (holiday-easter-etc -2 "Karfreitag")
                                     (holiday-easter-etc 0 "Ostersonntag")
                                     (holiday-easter-etc 1 "Ostermontag")
                                     (holiday-easter-etc 39
                                                         "Christi Himmelfahrt")
                                     (holiday-easter-etc 39 "Vatertag")
                                     (holiday-easter-etc 49 "Pfingstsonntag")
                                     (holiday-easter-etc 50 "Pfingstmontag")
                                     (holiday-easter-etc 60 "Fronleichnam")
                                     (holiday-fixed 11 1 "Allerheiligen")
                                     (holiday-float 12 0 -4 "1. Advent" 24)
                                     (holiday-float 12 0 -3 "2. Advent" 24)
                                     (holiday-float 12 0 -2 "3. Advent" 24)
                                     (holiday-float 12 0 -1 "4. Advent" 24)
                                     (holiday-fixed 12 25 "1. Weihnachtstag")
                                     (holiday-fixed 12 26 "2. Weihnachtstag"))
        holiday-hebrew-holidays nil
        holiday-islamic-holidays nil
        holiday-bahai-holidays nil
        holiday-oriental-holidays nil)
#+END_SRC

** Enable narrowing and region operations
These operations are disabled by default, because they confuse newcomers.  I’m
not a newcomer anymore ;)

#+BEGIN_SRC elisp
  ;; Run at full power please
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'narrow-to-region 'disabled nil)
  (put 'narrow-to-page 'disabled nil)
#+END_SRC

** Replace yes-or-no questions with y-or-n
Some operations which are considered more dangerous need confirmation by the
user.  Some even need more explicit confirmation by requiring the user to enter
yes and even press return.  I don’t like that.

#+BEGIN_SRC elisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Shrink the minibuffer after expanding it
The minibuffer automatically expands when the entered text becomes too long for
one line or when a linebreak is entered, but by default it doesn’t shrink again.

#+BEGIN_SRC elisp
  (setf resize-mini-windows t)

#+END_SRC

** Place the TAGS file
#+BEGIN_SRC elisp
  ;; (add-to-list 'tags-table-list (expand-file-name "TAGS" user-emacs-directory))
  (add-to-list 'tags-table-list (expand-file-name "code/src/emacs-25.1/src/TAGS" (getenv "HOME")))

#+END_SRC

** Scroll the compilation buffer
By default compilation buffers don’t scroll.  Also, stop scrolling on the first
error.

#+BEGIN_SRC elisp
  (setf compilation-scroll-output t)
  ;;we want to have the compilation window scroll automatically
  (setq compilation-scroll-output 'first-error)
  (setq-default compile-command "make -k -j ")
#+END_SRC

** Enable lexical binding in the scratch buffer
Normally the scratch buffer does not have lexical binding.  This is a sensible
default, but I still don’t like it, as I’m very used to having closures and all
the other goodies that lexical binding gives me.  I’m not sure this works.

#+BEGIN_SRC elisp
  (add-hook 'after-init-hook
            (lambda () (with-current-buffer (get-buffer "*scratch*")
                         (setf lexical-binding t))))

#+END_SRC

** Enable desktop mode
Emacs’ desktop save mode can save some state from one session to the next.  This
code enables it, and also makes Emacs try to save its state when killed while in
server mode.

#+BEGIN_SRC elisp
  (desktop-save-mode 1)
  ;;with this we try to save the desktop file when the emacs server is killed.
  (add-hook 'kill-emacs-hook (lambda () (desktop-save user-emacs-directory)))
#+END_SRC

** Save the clipboard to the kill-ring
Normally, Emacs treats the clipboard, or primary selection, or whatever the host
OS has, a bit differently than its own kill-ring.  This may be for legitimate
reasons, probably mainly historic.  At any rate, I want Emacs to place the
contents the OS supplies into the kill-ring.

#+BEGIN_SRC elisp
  (setf save-interprogram-paste-before-kill t)
#+END_SRC
** Don’t move point when inserting with the mouse
By default, Emacs moves point to the location of the mouse when inserting using
middle click.  This setting causes the insertion to happen at point, regardless
of where the mouse points.

#+BEGIN_SRC elisp
  (setf mouse-yank-at-point t)
#+END_SRC
* Install and configure =bbdb=
While BBDB is a little weird, it does not need a lot of configuration.  I
basically only tell it that I’m not an American.

#+BEGIN_SRC elisp
  (use-package bbdb
    :config
    (setf bbdb-file (expand-file-name "../bbdb" org-directory)
          bbdb-north-american-phone-number nil
          bbdb-phone-style nil))
#+END_SRC

* Install and configure evil mode
  :PROPERTIES:
  :header-args: :tangle no
  :END:
Evil provides a layer on top of Emacs to emulate vi like keybindings and modes
(called “states” in Evil parlance).

There is a special evil package which should be loaded before evil itself, as it
affects initial buffers like the scratch buffer.  For this reason we install
evil-leader before evil itself.

First, we want to set a variable which needs to be set before loading evil.  I
tried this in the :init phase of evil, but it doesn’t seem to work.

#+BEGIN_SRC elisp
  (setf evil-want-integration nil)
#+END_SRC

#+BEGIN_SRC elisp
  (use-package evil-leader
    :init
    (global-evil-leader-mode 1)
    (evil-leader/set-leader ",")
    (evil-leader/set-key
      "<SPC>" 'helm-M-x
      "f" 'helm-find-files
      "b" 'helm-mini
      "B" 'ibuffer-other-window
      "2" 'split-window-below
      "3" 'split-window-right
      "0" 'delete-window
      "wf" 'helm-find-files-other-window
      "wb" 'switch-to-buffer-other-window
      "wq" 'kill-this-buffer
      "g" 'magit-status
      "ha" 'apropos-command
      "hb" 'describe-bindings
      "hf" 'describe-function
      "hv" 'describe-variable
      "hk" 'describe-key
      "ho" 'describe-symbol
      "hi" 'info
      "k" 'schweers/kill-buffer
      "wo" 'ace-window)
    ;; (define-key evil-motion-state-map (kbd ",") nil)
    (global-evil-leader-mode 1))

  ;; (use-package evil
  ;;   :config
  ;;   (setf evil-cross-lines t))

  ;; (add-to-list 'load-path (expand-file-name "site-lisp/evil-collection/"
  ;;                                           user-emacs-directory))

  ;; (when (require 'evil-collection nil t)
  ;;   (evil-collection-init)
  ;;   (evil-mode 1))

  (use-package evil
    :ensure t
    :config
    (setf evil-cross-lines t)
    (evil-mode 1))

  (use-package evil-collection
    :after evil
    :ensure t
    :config
    (evil-collection-init))

  ;; (use-package evil-collection
  ;;   :custom (evil-collection-setup-minibuffer t)
  ;;   :init (evil-collection-init))
#+END_SRC

Wasamasa kindly wrote the following snippet for me.  I didn’t even ask for it.
It defines a textobject for defuns.

#+BEGIN_SRC elisp
  (defun forward-evil-defun (&optional count)
    "Move forward COUNT defuns.
  Moves point COUNT defuns forward or (- COUNT) defuns backward
  if COUNT is negative.  A defun is defined by
  `beginning-of-defun' and `end-of-defun' functions."
    (evil-motion-loop (dir (or count 1))
      (ignore-errors
        (if (> dir 0) (end-of-defun) (beginning-of-defun)))))

  (evil-define-text-object evil-a-defun (count &optional beg end type)
    (evil-select-an-object 'evil-defun beg end type count))

  (evil-define-text-object evil-inner-defun (count &optional beg end type)
    (evil-select-inner-object 'evil-defun beg end type count))

  (with-eval-after-load 'evil-maps
    (define-key evil-outer-text-objects-map (kbd "S") 'evil-a-defun)
    (define-key evil-inner-text-objects-map (kbd "S") 'evil-inner-defun))

#+END_SRC

Evil itself is all well and good for the novice user, yet some modes use rather
different keybindings, hence need extra evil bindings.  This is where Evil
plugins come to play.

** Setup evil-lispy
   :PROPERTIES:
   :header-args: :tangle no
   :END:
Lispy uses vi-like keybindings, yet implements them in its own magical way,
hence is by default incompatible with evil-mode.
#+BEGIN_SRC elisp
  (pc evil-lispy)
#+END_SRC

** Setup evil-magit
Magit also defines its own peculiar bindings, so again another plugin is
needed.

#+BEGIN_SRC elisp
  (use-package evil-magit)
#+END_SRC

** Setup evil-org
This mode introduces several bindings, apparently mostly for headings.

For some reason this code behaves in a really weird way.  When used in other
source blocks, it seems to work just fine, but in this block, I first have to
change to emacs state and back to normal again before the binding works as
intended.

#+BEGIN_SRC elisp
  (use-package evil-org
    :ensure t
    :after org
    :config
    (add-hook 'org-mode-hook 'evil-org-mode)
    (add-hook 'evil-org-mode-hook
              (lambda ()
                (evil-org-set-key-theme '(textobjects insert navigation additional
                                                      shift todo heading)))))

  (evil-leader/set-key
    "n" 'org-capture)
#+END_SRC

** Setup Helm integration
Without helm, life in Emacs is pretty meaningless.  Sadly, there is no readily
installable package to integrate Evil and Helm.

#+BEGIN_SRC elisp
  (define-key evil-ex-map "b " 'helm-mini)
  (define-key evil-ex-map "e" 'helm-find-files)
#+END_SRC

** Setup evil for info
+Info also has rather non-standard bindings, as one does not edit text here, it
is advisable to have evil be in emacs state.+  I’m not sure yet what to do
here.  Time might tell.

#+BEGIN_SRC elisp
  ;; (evil-set-initial-state 'Info-mode 'emacs)
#+END_SRC

As an added bonus, add bindings for j and k in Emacs state, as these are not
bound in info.

#+BEGIN_SRC elisp
  (define-key Info-mode-map (kbd "j") (kbd "C-n"))
  (define-key Info-mode-map (kbd "k") (kbd "C-p"))
#+END_SRC

** Setup evil-mu4e
   :PROPERTIES:
   :header-args: :tangle no
   :END:
   #+BEGIN_SRC elisp
     (condition-case nil
         (pc evil-mu4e)
       (file-error (warn "Could not load evil-mu4e.  Have you loaded mu4e?")))
   #+END_SRC

** TODO Add evil bindings for undo-tree

** TODO Add evil bindings for mark commands
* Install and enable paradox
  #+BEGIN_SRC elisp
    (use-package paradox
      :init (setf paradox-lines-per-entry 2)
      :demand t
      :config
      (setf paradox-execute-asynchronously t)
      (paradox-enable))
  #+END_SRC
* Install and configure async (for dired)
It can be found here: https://github.com/jwiegley/emacs-async

#+BEGIN_SRC elisp
  (use-package async)
#+END_SRC

* Configure =dired=
Dired is a little weird, but also really cool.  I really ought to get it going
in async mode though.

#+BEGIN_SRC elisp
  (autoload 'dired-async-mode "dired-async.el" nil t)
  (autoload 'dired-toggle-read-only "dired" nil t)
  (dired-async-mode 1)
  (put 'dired-find-alternate-file 'disabled nil)
#+END_SRC
** Automatically refresh dired
I want dired to do autorefresh, but be quiet about it.

#+BEGIN_SRC elisp
  (setf global-auto-revert-non-file-buffers t
        auto-revert-verbose nil)
#+END_SRC

** Enter =dired-dwim-target=
Make dired guess a destination for file operations.  If I recall correctly, the
directory of the buffer in =other-window= can be such a guess.  This can be done
by typing `o' in a dired buffer.

#+BEGIN_SRC elisp
  (setf dired-dwim-target t)
#+END_SRC
* Configure a few libraries
Normally, libraries don’t need to be configured, but dash provides some
font-locking.  Also, these libraries need to be installed before they can be
used.

Now that the =pc= macro has been defined, it can be used:

#+BEGIN_SRC elisp
  (use-package dash
    :config
    (setf dash-enable-fontlock t))

  (use-package dash-functional)
#+END_SRC

Also, some other libraries can now be installed:

#+BEGIN_SRC elisp
  (use-package f)
  (use-package json-mode
    :mode "\\.json")
  (use-package s)
#+END_SRC

The package [[https://github.com/abo-abo/hydra][hydra]] makes it easy to define several commands which share a prefix,
and provide a nice UI.

#+BEGIN_SRC elisp
  (use-package hydra)
#+END_SRC

* Setup the shells
Emacs provides several different ways to run a shell.  All of them are
configured here.

** Install =bash-completion=
Although I use the zsh, =shell= insists on having it.

#+BEGIN_SRC elisp
  (use-package bash-completion)
#+END_SRC
** Completion for =shell-command=
Emacs comes with a built-in command =shell-command=, by default bound to M-!,
which runs a shell command.  Thanks to the package =shell-command=,
shell-completion can be used.

The function =comint-kill-output-to-kill-ring= is bound to C-o in order to make
it easy to paste/yank the output anywhere, by placing it in the kill-ring.

#+BEGIN_SRC elisp
  (defun comint-kill-output-to-kill-ring (arg)
    "Kills all output from last command and puts it in kill buffer
  Does not delete the prompt."
    (interactive "P")
    (let ((proc (get-buffer-process (current-buffer)))
          (replacement nil)
          (inhibit-read-only t))
      (save-excursion
        (let ((pmark (progn (goto-char (process-mark proc))
                            (forward-line 0)
                            (point-marker))))
          ;; Add the text to the kill ring.
          (copy-region-as-kill comint-last-input-end pmark)
          (unless arg
            (delete-region comint-last-input-end pmark)
            (goto-char (process-mark proc))
            (setq replacement (concat "*** output flushed to kill ring ***\n"
                                      (buffer-substring pmark (point))))
            (delete-region pmark (point)))))
      ;; Output message and put back prompt
      (comint-output-filter proc replacement)))

  ;; (pc shell-command
  ;;   (:pre-install
  ;;    (autoload 'bash-completion-dynamic-complete
  ;;      "bash-completion"
  ;;      "BASH completion hook")
  ;;    (add-hook 'shell-dynamic-complete-functions
  ;;              'bash-completion-dynamic-complete)
  ;;    (add-hook 'shell-command-complete-functions
  ;;              'bash-completion-dynamic-complete))
  ;;   (:post-install
  ;;    (shell-command-completion-mode)

  ;;    (defun comint-delchar-or-eof-or-kill-buffer (arg)
  ;;      (interactive "p")
  ;;      (if (null (get-buffer-process (current-buffer)))
  ;;          (kill-buffer)
  ;;        (comint-delchar-or-maybe-eof arg)))

  ;;    (add-hook 'shell-mode-hook
  ;;              (lambda ()
  ;;                (define-key shell-mode-map (kbd "C-d")
  ;;                  'comint-delchar-or-eof-or-kill-buffer)
  ;;                (define-key shell-mode-map (kbd "C-c C-o")
  ;;                  'comint-kill-output-to-kill-ring)))))
  (use-package shell-command
    :init
    (autoload 'bash-completion-dynamic-complete
      "bash-completion"
      "BASH completion hook")
    (add-hook 'shell-dynamic-complete-functions
              'bash-completion-dynamic-complete)
    :config
    (shell-command-completion-mode 1)
    (defun comint-delchar-or-eof-or-kill-buffer (arg)
       (interactive "p")
       (if (null (get-buffer-process (current-buffer)))
           (kill-buffer)
         (comint-delchar-or-maybe-eof arg)))

     (add-hook 'shell-mode-hook
               (lambda ()
                 (define-key shell-mode-map (kbd "C-d")
                   'comint-delchar-or-eof-or-kill-buffer)
                 (define-key shell-mode-map (kbd "C-c C-o")
                   'comint-kill-output-to-kill-ring))))
#+END_SRC

* TODO Miscellaneous stuff
This section needs to be reorganized badly.  It is a conglomeration of code I
have accumulated over the years.  Some of it was copied, some other stuff was
written by myself.

** Reloading and recompiling
These functions are probably no longer of much use.  For now they stay.  They
are/were used to ensure that .elc files are kept up to date with their source
files.

#+BEGIN_SRC elisp
  (require 's)
  (require 'dash)
  (require 'dash-functional)

  (defun recompile-emacs-d ()
    (interactive)
    (byte-recompile-directory (expand-file-name "code" user-emacs-directory) 0 t)
    (byte-compile-file (or user-init-file
                           (expand-file-name "init.el" user-emacs-directory))))

  (defun file-in-emacs-d? (filename)
    (s-starts-with? (expand-file-name user-emacs-directory)
                    (expand-file-name filename)))

  (defun recompile-if-emacs-d ()
    (let ((filename (buffer-file-name (current-buffer))
           ))
      (if (and (file-in-emacs-d? filename) (s-ends-with? ".el" filename))
          (condition-case nil
              (byte-compile-file filename)
            (error
             (ignore-errors (delete-file (byte-compile-dest-file filename))))))))

  (defun reload-emacs-conf ()
    (interactive)
    (load user-init-file))

  ;; Autocompile any elisp files in our emacs directory.
  ;; (add-hook 'after-save-hook 'recompile-if-emacs-d)

  ;; Open the init file on startup.
  ;; (find-file-noselect (expand-file-name "init.el" user-emacs-directory))
#+END_SRC

** Buffer switching
A function to switch to the scratch buffer, because that is something I do very
often.  Also, a macro which generates a hydra, which then can switch between
buffers.  Note that these are used/bound elsewhere.

#+BEGIN_SRC elisp
  (defun misc/switch-to-scratch ()
    (interactive)
    (switch-to-buffer "*scratch*"))

  (defmacro misc/buffer-switch-hydra (hydra-name short-name key-prefix
                                                 &rest heads)
    (declare (indent 3))
    `(global-set-key
      (kbd ,key-prefix)
      ,(append
        `(defhydra ,hydra-name (:color pink) ,short-name)
        (append
         (-map
          (-lambda ((key b-or-n hint))
            `(,key (lambda ()
                     (interactive)
                     (switch-to-buffer ,b-or-n))
                   ,hint))
          heads)
         '(("q" nil "quit" :color blue))))))
#+END_SRC

** Create new setup files
This piece of code was used before I switched to having a literate
configuration.  It could create a new file, with a proper name and location.  It
also put in some boilerplate (like enabling lexical binding and adding a
=provide= clause), as well as placed point properly.  It also prompts the user
to add the new file to git (with magit).

#+BEGIN_SRC elisp
  (defun schweers/new-setup (name &optional stage)
    "Create a new setup file, called setup-NAME.el in
  ~/.emacs.d/code/ which enables lexical scoping, contains the
  appropriate provide and places point at the right position.

  If STAGE is non-nil, also stage the file with magit."
    ;; (interactive "MWhich package do you want to set up? \n")
    (interactive (list (read-string "Name of package to set up: ")
                       (cond
                        ((null current-prefix-arg)
                         (y-or-n-p "Do you want to stage the file with magit? "))
                        ((let ((p (if (consp current-prefix-arg)
                                      (car current-prefix-arg)
                                    current-prefix-arg)))
                           (or (eq p '-) (< p 0)))
                         nil)
                        (t t))
                       ;; (if current-prefix-arg
                       ;;     (let ((p (if (consp current-prefix-arg)
                       ;;                  (car current-prefix-arg)
                       ;;                current-prefix-arg)))
                       ;;       (if (or (null p) (eq p '-) (< p 0))
                       ;;           nil
                       ;;         t))
                       ;;   (y-or-n-p "Do you want to stage the file with magit? "))
                       ))
    (let ((proper-name (s-concat "setup-" name ".el")))
      (save-excursion
        (find-file
         (expand-file-name
          proper-name
          (expand-file-name "code" user-emacs-directory)))
        (when (or (buffer-narrowed-p) (/= (point-min) (point-max)))
          (error "File is not empty and/or the corresponding buffer is narrowed"))
        (goto-char (point-min))
        (insert ";; -*- lexical-binding: t -*-\n\n\n\n(provide '")
        (insert (substring proper-name 0 (- (length proper-name) 3)))
        (insert ")\n")
        (forward-line -3)
        (indent-for-tab-command)
        (save-buffer)
        (when stage
          (magit-stage-file (buffer-file-name)))
        (buffer-file-name))))
#+END_SRC

** TODO Start a browser with a youtube search of the unofficial Emacs anthem
While Emacs does not have an official anthem, the song „Hurra“ captures it very
nicely ;)

This does not work anymore, for some reason.  Maybe I’ll debug it at some
point.

#+BEGIN_SRC elisp
  (defun misc/hurra ()
    "Calls xdg-open (i.e. a browser) for a youtube search link for the song
  „hurra“.

  This song describes very nicely how it felt before and after knowing Emacs ;)"
    (interactive)
    (let* ((p (start-process
               "hurra" "hurra-out" "xdg-open"
               (s-concat "https://www.youtube.com/"
                         "results?search_query=die+%C3%A4rzte+hurra")))
           (pb (process-buffer p)))
      (set-process-sentinel
       p
       (lambda (_proc e)
         (cond ((string-match "finished" e)
                (kill-buffer pb)))))))
#+END_SRC

** Open the menu of the Olbia restaurant near the FH
As the section title claims, this code fetches the menu from a local restaurant
and displays it in Emacs (thanks to docview mode).

The http header has to be stripped, then docview-mode is activated.

#+BEGIN_SRC elisp
  (defun misc/olbia (arg)
    "Downloads the menu of the Pizzeria Olbia in Frankfurt/Main.

  Switches to the apropriate buffer if it already exists."
    (interactive "P")
    (let ((b (get-buffer "*Olbia*")))
      (cond (b (cond ((null arg) (switch-to-buffer b))
                     (t (switch-to-buffer-other-window b))))
            (t
             (url-retrieve
              "http://pizzeriaolbia.de/index_htm_files/Speisekarte%20032015.pdf"
              (lambda (_status)
                (rename-buffer "*Olbia*")
                (search-forward-regexp "%PDF")
                (beginning-of-line)
                (delete-region (point-min) (point))
                (doc-view-mode)
                (call-interactively #'misc/olbia)))))))
#+END_SRC

** Split quoted paragraph in =message-mode=
In message mode, it can be annoying to break up a quoted paragraph.  This
function fixes that.

#+BEGIN_SRC elisp
  (defun schweers/split-quoted-paragraph ()
    "Split the quoted paragraph at point, making space for a reply, and fill the
  rest of the paragraph.  This is useful in message-mode."
    (interactive)
    (let ((in-line (not (looking-at "[[:space:]]*$")))
          (level (save-excursion
                   (beginning-of-line)
                   (save-match-data
                     (if (looking-at ">*")
                         (- (match-end 0) (match-beginning 0))
                       0)))))
      (insert "\n")
      (delete-horizontal-space)
      (when (and in-line (> level 0))
        (insert (s-concat (s-repeat level ">") " ")))
      (beginning-of-line)
      (open-line (if in-line 3 2))
      (forward-line 1)
      (when in-line
        (save-excursion
          (forward-line 2)
  ;;; This binding is needed, so fill-paragraph won’t create an extra
  ;;; undo-boundary, which is normally done because of message-mode.
          (let ((fill-paragraph-function (lambda (&rest _) nil)))
            (fill-paragraph))))))
#+END_SRC

** Remake local etags
This function is probably broken, and not used anyway.

#+BEGIN_SRC elisp
  (defun remake-local-etags ()
    (interactive)
    (if (not (zerop
              (call-process "/bin/sh" nil nil nil
                            "-c" (format "cd %s; etags `find ./ -iname \\*.el`"
                                         user-emacs-directory))))
        (warn "etags failed.")))
#+END_SRC

** Define a named let
As an exercise I defined a macro to somewhat emulate schemes let recursion.
This is painfully slow, as it uses real (i.e. non-eliminated) recursion.

#+BEGIN_SRC elisp
  (defmacro +let (&rest args)
    "Allows scheme like recursion.

  A symbol may be given as an additional first argument, the rest is like `let'.
  If this extra argument is given, it is the name of a local function, which is
  created by this macro.  The bindings given in the second argument give the names
  of the arguments, and the values, with which the function is initially called."
    (let ((name (car args)))
      (if (symbolp name)
          (if (eq name nil)
              `(let ,@(cdr args))
            (let ((argnames (-map (lambda (binding)
                                    (if (consp binding)
                                        (car binding)
                                      binding))
                                  (second args)))
                  (init-args (-map (lambda (binding)
                                     (if (consp binding)
                                         (cadr binding)
                                       nil))
                                   (second args))))
              `(cl-labels ((,name ,argnames ,@(cddr args)))
                 (,name ,@init-args))))
        `(let ,@args))))
#+END_SRC

** Define a helper function for the dates of the critical mass
The critical mass in Frankfurt has a weird cycle, which normal calendar programs
cannot handle.  Luckily, Emacs has a Lisp VM \o/

#+BEGIN_SRC elisp
  (defun schweers/critical-mass-friday (date)
    (let ((friday?
           (+ 5 (do ((sunday? 1 (1+ sunday?)))
                    ((zerop (calendar-day-of-week
                             (list (first date) sunday? (third date))))
                     sunday?)))))
      (if (calendar-date-is-valid-p (list (first date) friday? (third date)))
          (if (calendar-date-equal (list (first date) friday? (third date)) date)
              "Critical Mass Frankfurt (19:00)"
            nil)
        (error "Bug in critical mass ffm friday"))))
#+END_SRC

** List all Lisp callable C functions
I wanted to know which functions are implemented in C, so I “wrote” this
function.

#+BEGIN_SRC elisp
  (defun misc/list-C-funs ()
    (interactive)
    (cl-labels
        ;; I copied and bastardized this from `describe-function-1'
        ((from-C-source-p
          (function)
          (let* ((advised (and (symbolp function)
                               (featurep 'nadvice)
                               (advice--p (advice--symbol-function function))))
                 ;; If the function is advised, use the symbol that has the
                 ;; real definition, if that symbol is already set up.
                 (real-function
                  (or (and advised
                           (advice--cd*r (advice--symbol-function function)))
                      function))
                 ;; Get the real definition.
                 (def (if (symbolp real-function)
                          (or (symbol-function real-function)
                              (signal 'void-function (list real-function)))
                        real-function))
                 (file-name (find-lisp-object-file-name function def)))
            (eq file-name 'C-source))))
      (with-current-buffer (generate-new-buffer "C functions")
        (insert "The following functions are implemented in C:\n\n")
        (mapatoms
         (lambda (x)
           (if (and (fboundp x) (from-C-source-p x))
               (insert (symbol-name x) "\n"))))
        (switch-to-buffer-other-window (current-buffer)))))
#+END_SRC

** TODO Toggle frame split
Toggle the way in which the frame is split.  Very fragile, probably not used at
all.

#+BEGIN_SRC elisp
  (defun toggle-frame-split ()
    "If the frame is split vertically, split it horizontally or vice versa.
  Assumes that the frame is only split into two.

  Got this from here: http://www.emacswiki.org/emacs/ToggleWindowSplit"
    (interactive)
    (unless (= (length (window-list)) 2) (error "Can only toggle a frame split in two"))
    (let ((split-vertically-p (window-combined-p)))
      (delete-window) ; closes current window
      (if split-vertically-p
          (split-window-horizontally)
        (split-window-vertically)) ; gives us a split with the other window twice
      (switch-to-buffer nil))) ; frame
                                          ; restore the original window in this part of the
#+END_SRC

** Mark the current line
The title says it all.

#+BEGIN_SRC elisp
  (defun misc/mark-line ()
    (interactive)
    (beginning-of-line)
    (push-mark (point) t t)
    (end-of-line))
#+END_SRC

** TODO A non-complete tea timer
   :PROPERTIES:
   :header-args: :tangle no
   :END:
Maybe I’ll finish this some day.

#+BEGIN_SRC elisp
  (defcustom tea-timer/alarm-clock-uri
    "http://www.orangefreesounds.com/wp-content/uploads/Zip/Old-alarm-clock-ringing.zip"
    "The command `tea-timer' will fetch the sound to play from this uri.")

  (defcustom tea-timer/fname-regexp
    "\\(?:\\(?:mp3\\)\\|\\(?:mp4\\)\\|\\(?:ogg\\)\\|\\(?:wav\\)\\)\\)$"
    "A regexp which matches audio files.

  The first matching file in an archive will be used as the sound of the alarm.")

  (defun tea-timer/fetch-file (uri)
    "Fetch and possibly extract the file behind the uri.

  Returns a local uri.  This function also tries to guess which file to pick if
  pointed to a zip file containing more than one file."

    (let ((fname
           (f-join
            "~/tmp"
            (f-filename (url-filename
                         (url-generic-parse-url tea-timer/alarm-clock-uri))))))
      (let ((curl-proc
             (start-process
              "curl" " curl-buffer" "curl" "-o" fname tea-timer/alarm-clock-uri)))
        (set-process-sentinel
         curl-proc
         (lambda (proc status)
           (when (not (process-live-p proc))
             (let ((unzip-proc
                    (start-process
                     "unzip" " unzip-buffer" "unzip" fname
                     "-d" (f-dirname fname) fname)))
               (set-process-sentinel
                unzip-proc
                (lambda (proc status)
                  (when (not process-live-p proc)
                    (f-move (f-join (f-dirname fname) ()))))))))))))

  (defun tea-timer (duration &optional description)
    (interactive "sDuration: \nsEnter a description: ")
    (run-at-time duration nil
                 (lambda ()
                   (start-process
                    "teetimer-sound-aplay"
                    " teetimer-sound-aplay"
                    "aplay"
                    "/home/schweers/downloads/alarm-clock.wav")
                   (message "%s" description))))

  ;; (defun tee (name)
  ;;   (interactive ))

  ;; (completing-read "Which tee? " '(("Pfefferminz" 3) ("Kamille" 2)
  ;;                                 ("Earl Gray" 1))
  ;;                  nil t)

  ;; (start-process "teetimer-sound-aplay" " teetimer-sound-aplay"
  ;;                "aplay" "/home/schweers/downloads/alarm-clock.wav")

#+END_SRC

** A poor man’s presentation mode
This code allows me to increase and decrease the font height.  Most importantly,
it allows me to reset it to /my/ default, not what Emacs thinks is the default.

#+BEGIN_SRC elisp
  (defun schweers/adjust-font-height (fn arg)
    "Calls FN with the current font height and ARG.  Sets height to result."
    (set-face-attribute
     'default nil :height
     (funcall fn (face-attribute 'default :height) arg)))

  (defun schweers/get-adjustment (arg)
    "Depending on ARG, return an int.

  The returned integer represents by how much the font height shall be adjusted.

  ARG is supposed to be in the form of a raw prefix argument.

  If ARG is - set to the default font size \(see ‘schweers/default-font-height’\).
  If ARG is an integer, return it as is.
  If ARG is a list containing one int, return its log base 4 as an integer
  \(i.e. how often C-u was pressed\) multiplied by 10.
  If ARG is nil return 10."
    (cond ((null arg) 10)
          ((and (listp arg)
                (= (length arg) 1)
                (integerp (car arg)))
           (* 10 (floor (log (car arg) 4))))
          ((and (symbolp arg) (eq arg '-))
           schweers/default-font-height)
          ((integerp arg) 10)))

  (defun schweers/increase-font (arg)
    "Increase the font size by 10 points.
  If a prefix is given, increase by PREFIX points.
  If C-u is pressed repeatedly, the font size is increased by 10 times the number
    of keystrokes."
    (interactive "P\n")
    (schweers/adjust-font-height
     (if (and (symbolp arg) (eq arg '-))
         (lambda (_cur new)
           new)
       #'+)
     (schweers/get-adjustment arg)))

  (defun schweers/decrease-font (arg)
    "Increase the font size by 10 points.
  If a prefix is given,decrease by PREFIX points.
  If C-u is pressed repeatedly, the font size is decreased by 10 times the number
    of keystrokes."
    (interactive "P\n")
    (schweers/adjust-font-height
     (if (and (symbolp arg) (eq arg '-))
         (lambda (_cur new)
           new)
       #'-)
     (schweers/get-adjustment arg)))
#+END_SRC

** Kill the current buffer
When I kill a buffer, it is almost always the buffer I have selected.  So I
defined a command, which kills the current buffer, unless a prefix is given.  If
so, it behaves like =kill-buffer=.

#+BEGIN_SRC elisp
  (defun schweers/kill-buffer (arg)
    "Kill current buffer, unless called with prefix.

  If prefix is present, ask which buffer to kill. "
    (interactive "P")
    (if arg
        (call-interactively 'kill-buffer)
      (kill-buffer (current-buffer))))
#+END_SRC

** Jump to a setup file
As I previously used separate elisp files which could be compiled and required.
To ease jumping to such a file, I wrote this code.  It works by exploiting the
fact, that all such files reside in a folder "code", begin by "setup-" and end
with ".el".

#+BEGIN_SRC elisp
  (defun schweers/list-setup-files ()
    (f-entries (expand-file-name "code" user-emacs-directory)
               (lambda (fname)
                 (and (string-match-p "^setup" (f-base fname))
                      (string-match-p "\\.el$" fname)))))

  (defun schweers/list-setup-names ()
    (map
     (lambda (setup)
       (substring (f-base setup) 6))
     (schweers/list-setup-files)))

  (defun schweers/switch-to-setup-file (mode other-window-p)
    "Switch to the file which sets up MODE-NAME.

  If OTHER-WINDOW-P is non-nil, open the file in other window."
    (interactive
     (list (completing-read "Switch to setup file: "
                            (schweers/list-setup-names))
           current-prefix-arg))
    (let ((fname? (assoc
                   mode
                   (cl-loop for f in (schweers/list-setup-files)
                            for s in (schweers/list-setup-names)
                            collect `(,s . ,f)))))
      (unless fname?
        (setf fname? (list mode (schweers/new-setup mode t))))
      (if other-window-p
          (find-file-other-window (cdr fname?))
        (find-file (cdr fname?)))))
#+END_SRC
* Load and Configure =mu4e=
  :PROPERTIES:
  :header-args: :tangle no
  :END:
  I’ll try this again

  #+BEGIN_SRC elisp
    (condition-case nil
        (progn
          (require 'mu4e)
          (require 'org-mu4e)
          (add-to-list 'mu4e-bookmarks
                       (make-mu4e-bookmark
                        :name "debian user"
                        :query "list:debian-user.lists.debian.org"
                        :key ?d))
          (add-to-list 'mu4e-bookmarks
                       (make-mu4e-bookmark
                        :name "gitlab"
                        :query "from:gitlab@code.outdooractive.com"
                        :key ?g))
          (add-to-list 'mu4e-bookmarks
                       (make-mu4e-bookmark
                        :name "non-list unread"
                        :query (concat
                                "flag:unread and not flag:list "
                                "and not from:gitlab@code.outdooractive.com")
                        :key ?n))
          (setf mu4e-contexts
                (list
                 (make-mu4e-context
                  :name "Outdooractive"
                  :vars
                  '((mu4e-maildir . "~/Maildir/OA/")
                    (mu4e-sent-folder . "/Sent")
                    (mu4e-drafts-folder . "/Drafts")
                    (mu4e-trash-folder . "/Trash")
                    (mu4e-refile-folder . "/Archive")
                    (mu4e-get-mail-command . "mbsync OA")
                    (mu4e-update-interval . 120)))
                 (make-mu4e-context
                  :name "online.de"
                  :vars
                  '((mu4e-maildir . "~/Maildir/1&1/")
                    (mu4e-sent-folder . "/Sent")
                    (mu4e-drafts-folder . "/Drafts")
                    (mu4e-trash-folder . "/Trash")
                    (mu4e-refile-folder . "/Archive")
                    (mu4e-get-mail-command . "mbsync 1u1")
                    (mu4e-update-interval . 120)))
                 (make-mu4e-context
                  :name "mailbox.org"
                  :vars
                  '((mu4e-maildir . "~/Maildir/mailbox")
                    (mu4e-sent-folder . "/Sent")
                    (mu4e-drafts-folder . "/Drafts")
                    (mu4e-trash-folder . "/Trash")
                    (mu4e-refile-folder . "/Archive")
                    (mu4e-get-mail-command . "mbsync mailbox")
                    (mu4e-update-interval . 600))))))
      (file-error (warn "no mu4e found."))
      (error (warn "mu4e could not be loaded.")))
  #+END_SRC

* Install and configure =guide key=
The package =guide-key= makes it a little easier to explore prefixed
keybindings.  The variable =guide-key/guide-key-sequence= holds a list of
prefixes.  When either of them is pressed, it displays the possible further
keystrokes at the bottom of the screen.

#+BEGIN_SRC elisp
  ;; (pc guide-key
  ;;   (:post-install
  ;;    (setf guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-x 5" "C-x v" "C-x 8"
  ;;                                         "C-x n" "C-c C-x" "C-x c" "C-c p"))
  ;;    (guide-key-mode 1)
  ;;    (setf guide-key/recursive-key-sequence-flag t
  ;;          guide-key/popup-window-position 'bottom
  ;;          guide-key/idle-delay 0.1)))

  (use-package which-key)
#+END_SRC

* Common configuration for all lisps
As all lisps share some similarities, some settings can be applied to all of
them.  This is the place to collect them.  A particularly useful package is
lispy, which is an alternative to paredit.

#+BEGIN_SRC elisp
  (defvar schweers/*lisp-mode-hooks*
    '(clojure-mode-hook cider-repl-mode-hook emacs-lisp-mode-hook
                        lisp-mode-hook slime-repl-mode-hook
                        scheme-mode-hook inferior-scheme-mode-hook
                        ;; geiser-mode-hook
                        ;; geiser-repl-mode-hook
                        ))

  (defun schweers/make-lisp-great-again ()
    (lispy-mode 1)
    (subword-mode -1)
    (define-key lispy-mode-map [remap backward-delete-char]
      'lispy-delete-backward)
    (setf lispy-delete-backward-recenter nil))

  (use-package lispy
    :demand t
    :bind (("C-M-1" . lispy-describe-inline)
           ("C-M-2" . lispy-arglist-inline)
           ("C-M-3" . lispy-right))
    :config
    (dolist (m schweers/*lisp-mode-hooks*)
      (add-hook m #'schweers/make-lisp-great-again))

    (defun schweers/lispy-M-paren ()
      (interactive)
      (let ((current-prefix-arg '(1)))
        (call-interactively 'lispy-parens)))

    (define-key lispy-mode-map (kbd "M-(") 'schweers/lispy-M-paren)
    (define-key lispy-mode-map (kbd "#") 'self-insert-command)
    (define-key lispy-mode-map (kbd ":") 'self-insert-command)
    (define-key lispy-mode-map (kbd "C-w") 'lispy-backward-kill-word))
#+END_SRC

Unfortunately, the binding to C-w doesn’t work here, as I bind it in my own
minor mode which takes precedence.

* TODO Configure =autocomplete=
  :PROPERTIES:
  :header-args: :tangle no
  :END:
Autocomplete is quite nice, but I’m not sure whether it conflicts with
=company-mode=.

#+BEGIN_SRC elisp
  (pc auto-complete
    (:require (require 'auto-complete-config))
    (:post-install
     (add-to-list 'ac-user-dictionary-files (concat user-emacs-directory "ac-dict"))
     (ac-config-default)
     (ac-set-trigger-key "TAB")
     ;; (add-hook 'slime-mode-hook 'set-up-slime-ac)
     ;; (add-hook 'slime-repl-mode 'set-up-slime-ac)
     ;; (eval-after-load "auto-complete"
     ;;   '(add-to-list 'ac-modes 'slime-repl-mode))
     ))
#+END_SRC

* Install and configure =company-mode=
Company mode promises to be like autocomplete, yet with less setup, so I’ll try
it out.

#+BEGIN_SRC elisp
  (use-package company
    :init (add-hook 'after-init-hook 'global-company-mode))
  (use-package slime-company
    :after slime)
  (use-package helm-company
    :bind (:map company-mode-map
                ("M-S-SPC" . helm-company)
                :map company-active-map
                ("M-S-SPC" . helm-company)))
#+END_SRC
* Configure =magit=
As far as I know, magit is simply the best interface to git.  As I normally
place all my code under ~/code, I tell magit this is the case.

#+BEGIN_SRC elisp
  (use-package magit
    ;; :init
    ;; (require 's)
    :bind (("C-c m" . magit-status))
    :config
    (setf magit-repo-dirs (list (s-join "/" (list (getenv "HOME") "code"))
                                user-emacs-directory)
          magit-repo-dirs (list (getenv "HOME"))
          magit-last-seen-setup-instructions "1.4.0"))
#+END_SRC

* Some global keybindings
Most of my global keybindings are part of my own minor mode, but for a few of
them it is easier to make them truly global.

#+BEGIN_SRC elisp
  (global-set-key (kbd "C-c M-x") 'execute-extended-command)
  (global-set-key (kbd "M-S-<f10>") 'menu-bar-mode)

  (defhydra hydra-page (ctl-x-map "" :pre (widen))
    "page"
    ("]" forward-page "next")
    ("[" backward-page "prev")
    ("n" narrow-to-page "narrow" :bind nil :exit t)
    ("q" nil "quit"))

  (windmove-default-keybindings)

  (global-set-key (kbd "<C-tab>") 'completion-at-point)

  (misc/buffer-switch-hydra hydra-irc "channel" "C-c i"
    ("n" "#neo" "neo")
    ("e" "#emacs" "emacs")
    ("f" "irc.freenode.net:6667" "freenode"))

  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c c") 'org-capture)
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c b") 'org-iswitchb)

#+END_SRC

* Configure python for =elpy=
Elpy is sort of an IDE for python in Emacs.  I don’t really like it, but it’s
better than nothing.  Also, it shows where one deviates from Guido’s personal
favorites, so he won’t cry too much when reading my code.

#+BEGIN_SRC elisp
  (use-package elpy
    :config
    (add-hook 'python-mode-hook
              (lambda () (setf fill-column 79)))
    (elpy-enable))
#+END_SRC

* Configure and bind =ace-window=
Ace window makes switching windows much more pleasant.  Instead of switching
from one to the next, one can directly jump to any visible window.  Note that
this is a little weird when using more than one frame.

#+BEGIN_SRC elisp
  (use-package ace-window
    :bind (("C-x o" . ace-window))
    :config
    (setf aw-scope 'frame
          aw-keys '(?b ?n ?r ?s ?g ?o ?e ?i ?t ?c)))
#+END_SRC

* Install and Setup Org Mode
As Org Mode is a huge application in its own right, it needs a lot of
configuration.

** Installation
As Emacs ships with an almost ancient version of Org Mode, I want a newer
version.  Luckily Org Mode has an extra elpa repository, which I have set up
[[*Add%20Org%20Mode%20repo][here]].

Normally I’d just put my setup into use-package, but as I already have a lot of
settings spread out over this file, I want it to stay that way.  Plus, I
/always/ load Org Mode anyway, so there is no point to lazy loading.

#+BEGIN_SRC elisp
  (use-package org
    :ensure org-plus-contrib
    :demand t)
#+END_SRC

** Setup indentation
The first step is that I’d like Org Mode to indent when I enter a newline by
default.

#+BEGIN_SRC elisp
  (defun setup-org/define-newline-keys ()
    (define-key org-mode-map (kbd "RET") 'org-return-indent)
    (define-key org-mode-map (kbd "C-j") 'org-return))
#+END_SRC

** Setup notes
Also, I want the notes file which I use with org-capture to reside inside my
.emacs.d directory.  This might as well change in the future.
#+BEGIN_SRC elisp
  (setf org-directory
        (cond ((eq system-type 'windows-nt)
               (expand-file-name "Nextcloud/org" (getenv "USERPROFILE")))
              ((string= system-name "spinetail")
               (expand-file-name ".emacs_data" (getenv "HOME")))
              (t
               (expand-file-name "Nextcloud/org" (getenv "HOME"))))
        ;; (expand-file-name (if (string= system-name "spinetail")
        ;;                       ".emacs_data"
        ;;                     ;; ".emacs_data"
        ;;                     "Nextcloud/org")
        ;;                   (getenv "HOME"))
        org-default-notes-file
        (expand-file-name "notes.org" org-directory)
        org-agenda-files
        ;; "notes.org"
        ;; (directory-files org-directory nil "\\.org$")
        (list (expand-file-name "notes.org" org-directory)
              (expand-file-name ".emacs_data_oa/notes.org"
                                (getenv "HOME")))
        ;; (list (expand-file-name (if (string= system-name "spinetail")
        ;;                             ".emacs_data/notes.org"
        ;;                           ".emacs_data/notes.org")
        ;;                         (getenv "HOME"))
        ;;       (expand-file-name ".emacs_data_oa/notes.org"
        ;;                         (getenv "HOME")))
        org-special-ctrl-a/e t
        org-special-ctrl-k t
        org-special-ctrl-o t)
#+END_SRC

*** Setup keyword states
    Org Mode can have more than just the three states "", "TODO" and "DONE".

    #+BEGIN_SRC elisp
      (setf org-todo-keywords '((sequence "TODO" "|" "DONE" "CANCELLED")))
    #+END_SRC

** Setup MobileOrg
Apparently, one is supposed to have a staging area of some sort to which to push
inside Emacs.

#+BEGIN_SRC elisp
  (setf org-mobile-directory "~/Nextcloud/MobileOrg")
#+END_SRC

It seems that MobileOrg pulls data into the file named by this variable.  Note
that the file must exist.  The mobile data is appended to this file and the
server contents is emptied.  Which I find at least weird, if not plain wrong.

#+BEGIN_SRC elisp
  (setf org-mobile-inbox-for-pull (expand-file-name "mobile.org" org-directory))
#+END_SRC

Maybe I have to set which files to sync more explicitly?

#+BEGIN_SRC elisp
  (setf org-mobile-files "notes.org")
#+END_SRC

** Org is the new Fundamental
   :PROPERTIES:
   :header-args: :tangle no
   :END:
I want Org Mode to be the default major mode instead of fundamental mode.  This
should be the right thing for the vast majority of files, as Org Mode is all
ASCII text anyway.  I’m not really sure this works though, so I’ve left it out
for now.

#+BEGIN_SRC elisp
  (add-to-list 'magic-fallback-mode-alist '((lambda () t) . org-mode))
#+END_SRC

One of the great features of Org Mode is that it can work with source blocks
(like in this file!).  It can also fontify them properly, using the appropriate
modes.  Why this is not the default is beyond me.

** Setup font-locking
#+BEGIN_SRC elisp
  (setf org-src-fontify-natively t)
#+END_SRC

** Export to LaTeX/PDF
Org Mode can export to LaTeX, hence to PDF, but it needs some help in doing so.
This next block of code imports the new exporter and configures it for some
classes that are not by default configured.

#+BEGIN_SRC elisp
  (require 'ox-latex)
  (setf org-latex-inputenc-alist '(("utf8" . "utf8x")))
  (add-hook 'org-mode-hook
            (lambda ()
              (add-to-list 'org-latex-classes
                           '("IEEEtran"
                             "\\documentclass[conference]{IEEEtran}"
                             ("\\section{%s}" . "\\section*{%s}")
                             ("\\subsection{%s}" . "\\subsection*{%s}")
                             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                             ("\\paragraph{%s}" . "\\paragraph*{%s}")
                             ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
              (add-to-list 'org-latex-classes
                           '("scrartcl"
                             "\\documentclass{scrartcl}"
                             ("\\section{%s}" . "\\section*{%s}")
                             ("\\subsection{%s}" . "\\subsection*{%s}")
                             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                             ("\\paragraph{%s}" . "\\paragraph*{%s}")
                             ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
              (add-to-list 'org-latex-classes
                           '("scrlttr2"
                             "\\documentclass{scrartcl}"
                             ("\\section{%s}" . "\\section*{%s}")
                             ("\\subsection{%s}" . "\\subsection*{%s}")
                             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                             ("\\paragraph{%s}" . "\\paragraph*{%s}")
                             ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
              (flyspell-mode 1)
              (define-key org-mode-map [remap backward-delete-char]
                'org-delete-backward-char)))
#+END_SRC

Also, I want source code blocks to be syntax colored.  Sadly, this is not the
same coloring as in source blocks.  Instead, the LaTeX package =minted= is used.

#+begin_comment
#+BEGIN_SRC elisp
  (setf org-latex-listings 'minted)
  ;; (add-to-list 'org-latex-packages-alist '("" "listings"))
  ;; (add-to-list 'org-latex-packages-alist '("" "color"))
  (add-to-list 'org-latex-packages-alist '("" "minted"))

  (setf
   org-latex-pdf-process
   '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
     "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
     "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC
#+end_comment

** Add font-locking for html output
Just as LaTeX output may be syntax highlighted, I want something similar for
html.

#+BEGIN_SRC elisp
  (use-package htmlize)
#+END_SRC

** Add a template/shortcut for Org Mode comment blocks
Org Mode files can contain comments, just like any other language.  They may
begin with a # to comment a line, or may be a block like a source block.

#+BEGIN_SRC elisp
  (add-to-list 'org-structure-template-alist '("C" "#+BEGIN_COMMENT\n?\n#+END_COMMENT"))

#+END_SRC

** Add a capture template
The command =org-capture= can capture in many formats and to many files.  I took
the default and only slightly changed it.

#+BEGIN_SRC elisp
  (setf org-capture-templates
        `(("t" "Task" entry
           (file+headline ,org-default-notes-file
                          "Tasks")
           "* TODO %?\n  %t\n  %a  %i\n")
          ("n" "Notes" entry
           (file+headline ,org-default-notes-file
                          "Notes")
           "* %?\n  %t\n  %a  %i\n")))

#+END_SRC

** Make Org Mode use TeX string delimiters
   :PROPERTIES:
   :header-args: :tangle no
   :END:
This command either inserts the empty TeX string ``'' at point, or surrounds the
region with these quote characters.  It does not deactivate the region.  Also,
the region contains the newly inserted quotes.

#+BEGIN_SRC elisp
  (defun schweers/org-TeX-string (beg end &optional point)
    "Insert a pair of TeX string delimiters (`` and '').

  Put these back to back with point between them, or around the region, if
  active.  Extend the region to contain the new delimiters too."
    (interactive "rd")
    (unless point
      (setf point (point)))
    (if (not (use-region-p))
        (progn
          (insert "``''")
          (backward-char 2))
      (let ((at-beginning-p (= beg point)))
        (goto-char end)
        (insert "''")
        (when at-beginning-p
          (push-mark (point)))
        (goto-char beg)
        (insert "``")
        (if at-beginning-p
            (backward-char 2)
          (push-mark (- (point) 2))
          (goto-char (+ 4 end)))
        (setf deactivate-mark nil))))

  (define-key org-mode-map (kbd "M-\"") #'schweers/org-TeX-string)

#+END_SRC

** A poor man’s presenter in Org Mode
Org Mode can be used as a poor man’s presenter.  This can come in handy when one
wants a live Emacs session, for instance because one wants to demonstrate
features of Emacs.  I did this for the presentation of my master thesis.  I
shamelessly +stole+ borrowed this code from someplace online.

#+BEGIN_SRC elisp
  (defun ded/org-show-next-heading-tidily ()
    "Show next entry, keeping other entries closed."
    (interactive)
    (if (save-excursion (end-of-line) (outline-invisible-p))
        (progn (org-show-entry) (outline-show-children))
      (outline-next-heading)
      (unless (and (bolp) (org-on-heading-p))
        ;; (org-up-heading-safe)
        ;; (hide-subtree)
        (error "Boundary reached"))
      (org-overview)
      (org-reveal t)
      (org-show-entry)
      (outline-show-children)))

  (defun ded/org-show-previous-heading-tidily ()
    "Show previous entry, keeping other entries closed."
    (interactive)
    (let ((pos (point)))
      (outline-previous-heading)
      (unless (and (< (point) pos) (bolp) (org-on-heading-p))
        (goto-char pos)
        (outline-hide-subtree)
        (error "Boundary reached"))
      (org-overview)
      (org-reveal t)
      (org-show-entry)
      (outline-show-children)))

  (define-key org-mode-map (kbd "<f8>") 'ded/org-show-previous-heading-tidily)
  (define-key org-mode-map (kbd "<f9>") 'ded/org-show-next-heading-tidily)
#+END_SRC

** Set up the archive filename
Org Mode normally adds the string "_archive" to the file name, yet this doesn’t
work well with gpg encrypted files.  For this reason I’ll simply put "archive_"
at the beginning of the new file name.

#+BEGIN_SRC elisp
  (setf org-archive-location "archive_%s::")
#+END_SRC
** Set up diary integration
Org Mode can include items from the excellent diary package (which can represent
recurring events of arbitrary complexity).  Only one variable needs to be set.

#+BEGIN_SRC elisp
  (setq org-agenda-include-diary t)
#+END_SRC
** Set the format for org-clock
Org mode supports clocking, which is really cool, but by default it folds
durations which are longer than 24h into days.  The following setting changes
that.

Note that the first setting is now obsolete.  I’ll leave it here for the time
being, but it should only have effect on older org mode versions.  At the time
of this writing (<2017-10-12 Thu>) the built-in version of Org Mode should still
use the old variable.

#+BEGIN_SRC elisp
  (setf org-time-clocksum-format
        '(:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t)
        org-duration-format 'h:mm)
  (setf org-time-clocksum-format
        '(:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t))
#+END_SRC
** Let org-clock include the current task
By default org-clock ignores the current task in report tables.  This is not
good.

#+BEGIN_SRC elisp
  (setf org-clock-report-include-clocking-task t)
#+END_SRC
** clock into a drawer
#+BEGIN_SRC elisp
  (setf org-clock-into-drawer t)
#+END_SRC
** Make clocks persistent
#+BEGIN_SRC elisp
  (setf org-clock-persist 'history)
  (org-clock-persistence-insinuate)
#+END_SRC
** Allow org-babel to evaluate shell scripts
For security reasons, org-babel normally doesn’t execute shell scripts.

#+BEGIN_SRC elisp
  (add-to-list 'org-babel-load-languages
               '(shell . t))
  ;; (add-to-list 'org-babel-load-languages
  ;;              '(sh . t))
  ;; (require 'ob-sh)
#+END_SRC
** Allow org-babel to evaluate lisp code
As [[*Allow org-babel to evaluate shell scripts][above]], Common Lisp is not allowed by default.
#+BEGIN_SRC elisp
  (add-to-list 'org-babel-load-languages
               '(lisp . t))
  (require 'ob-lisp)
#+END_SRC
** Load org languages
Actually load the languages.
#+BEGIN_SRC elisp
  (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages)
#+END_SRC
** Install =orgit=
   :PROPERTIES:
   :header-args: :tangle no
   :END:
Thanks to =orgit= it is possible to create links to magit buffers in Org Mode.
Sadly this pulls in a new version of Org Mode, which breaks things for my setup
which is why I have excluded it from my setup, at least for now.

#+BEGIN_SRC elisp
  (pc orgit)
#+END_SRC

** Activate dot source blocks
GraphViz uses files in a language called dot

#+BEGIN_SRC elisp
  ;; (org-babel-do-load-languages
  ;;  'org-babel-load-languages
  ;;  '((dot . t)))

  (add-to-list 'org-babel-load-languages
                 '(dot . t))
#+END_SRC
** Configure publishing projects
   Org Mode can apparently publish projects from a given directory to another
   directory or server.
* Install =graphviz-dot-mode=
#+BEGIN_SRC elisp
  (use-package graphviz-dot-mode
    :mode "\\.dot"
    :config
    (add-to-list 'org-src-lang-modes
                 '("dot" . graphviz-dot)))
#+END_SRC
* Install markdown-mode
Some people insist on using markdown instead of org mode.  While I cannot help
such misguided souls, I can install a mode to make reading their stuff a little
easier.

#+BEGIN_SRC elisp
  (use-package markdown-mode
    :mode "\\.md")
#+END_SRC
* Install tracwiki-mode
  :PROPERTIES:
  :header-args: :tangle no
  :END:

As with markdown, this is not Org Mode :(

#+BEGIN_SRC elisp
  (condition-case nil
      (pc tracwiki-mode)
    (error (warn "Could not load tracwiki-mode.")))
#+END_SRC
* Configure spell checking
I don’t remember why I put this in here the way it is, but it seems to work
somehow.  The command =ispell-change-dictionary= can be used to switch the
active dictionary.

#+BEGIN_SRC elisp
  (require 'ispell)

  (add-to-list
   'ispell-local-dictionary-alist
   '("deutsch-hunspell"
     "[[:alpha:]]"
     "[^[:alpha:]]"
     "['ß]"
     nil
     ("-d" "de_DE")                       ; Dictionary file name
     nil
     iso-8859-1))

  (add-to-list
   'ispell-local-dictionary-alist
   '("english-hunspell"
     "[[:alpha:]]"
     "[^[:alpha:]]"
     "[']"
     nil
     ("-d" "en_US")
     nil
     iso-8859-1))
#+END_SRC

* Configure =AUCTeX=
AUCTeX is /the/ major mode for editing LaTeX, although I do prefer Org Mode
whenever possible.

** A few shortcuts for my thesis
In my master thesis I used lots of code blocks, most of them some lisp or other.
I needed a few shortcuts to place them.  I may never use them again.

#+BEGIN_SRC elisp
  (defun schweers/LaTeX-put-lisp-block (caption label)
    (interactive "*MCaption: \nMLabel: ")
    (let ((create-par? (not (and (looking-at-p "$")
                                 (looking-back "^" (max (- (point) 2) 1))))))
      (when create-par?
        (insert "\n\n"))
      (insert "\\begin{lstlisting}[style=lispcode")
      (when caption
        (insert ",caption={" caption "}"))
      (when label
        (insert ",label={" label "}"))
      (insert "}\n\\end{lstlisting}")
      (when create-par?
        (insert "\n"))
      (beginning-of-line (if create-par? -2 -3))
      (insert "\n")))

  (defun schweers/lispinline ()
    "Insert a `lispinline' lstlisting at point."
    (interactive)
    (goto-char
     (save-mark-and-excursion
      (let ((beg (point)))
        (insert "\\begin{lstlisting}[style=lispinline]\n\n\\end{lstlisting}")
        (let ((end (point)))
          (goto-char beg)
          (fill-paragraph)
          (goto-char end)
          (forward-line -1)
          (point))))))

  (defun schweers/lispcode (caption label)
    "Insert a `lispcode' lstlisting at point."
    (interactive "MCaption: \nMLabel: ")
    (goto-char
     (save-mark-and-excursion
      (let ((beg (point)))
        (insert
         (format
          "\\begin{lstlisting}%s\n\n%s"
          (format "[style=lispcode,label={%s},caption={%s},numbers=left]"
                  label caption)
          "\\end{lstlisting}"))
        (let ((end (point)))
          (goto-char beg)
          (fill-paragraph)
          (goto-char end)
          (forward-line -1)
          (point))))))
#+END_SRC

** Install and configure AUCTeX
Sadly, AUCTeX does not come with Emacs, so it must be installed.  Also, we want
to create PDF files by default (no DVI files please).  Also, activate synctex so
one can jump from the TeX source to the PDF location and vice versa.

Another useful thing I do here is to activate outline mode, as it provides some
more jump locations.

#+BEGIN_SRC elisp
  (use-package tex
    :ensure auctex
    :after latex
    :config
    (setf LaTeX-command "latex")
    (add-hook
     'LaTeX-mode-hook
     (lambda ()
       (TeX-PDF-mode)
       ;; (push '(pdf . pdfsync)
       ;;       TeX-source-correlate-method)
       (define-key LaTeX-mode-map
         [remap backward-delete-char]
         'delete-backward-char)
       (define-key LaTeX-mode-map (kbd "M-\"")
         #'schweers/org-TeX-string)
       (TeX-source-correlate-mode 1)
       (flyspell-mode 1)
       (setf (cdr (assoc "subsection"
                         LaTeX-section-label))
             "subsec:"
             (cdr (assoc "subsubsection"
                         LaTeX-section-label))
             "subsubsec:")
       (outline-minor-mode 1))))
#+END_SRC

* Configure =gnus=
While my gnus file is quite large, for some reason gnus insists on having its
own file.  I’ve convinced it to please not use the home directory for this.  I
used to have this file in ~/.emacs.d, but as its more data than config, I’ve
moved this file to ~/.emacs_data/gnus.el.

#+BEGIN_SRC elisp
  (load (expand-file-name
         "gnus.el"
         (expand-file-name (if (string= system-name "spinetail")
                               ".emacs_data_oa"
                             ".emacs_data")
                           (getenv "HOME"))))

#+END_SRC

* Install =notmuch=
#+BEGIN_SRC elisp
  (use-package notmuch
    :commands notmuch
    :config
    (define-key notmuch-show-mode-map "U" 'browse-url-at-point)
    (setf notmuch-crypto-process-mime t)
    ;; (bbdb-initialize 'message 'pgp 'gnus)
    (require 'org-notmuch))
#+END_SRC

* Configure =mu4e=
  :PROPERTIES:
  :header-args: :tangle no
  :END:
  This is one of the few packages which I do not install via elpa.  Sane
  distributions have versions of Emacs which are not from the previous century,
  but on debian I’ll have to add a load path.

  Possibly I could use linux introspection to see where we are installed.  Or I
  could just force the path in.

  #+BEGIN_SRC elisp
    (condition-case nil
        (progn
          (require 'mu4e)
          (require 'org-mu4e)
          (add-to-list 'mu4e-bookmarks
                       (make-mu4e-bookmark
                        :name "Unread non-list"
                        :query "flag:unread and not flag:list"
                        :key ?n)))
      (file-error (warn "Could not load mu4e")))
  #+END_SRC
* Install and configure =multiple-cursors=
Multiple cursors is a nice shorthand for keyboard macros.  They save a lot of
time when one is not /exactly/ sure what needs to be done.

#+BEGIN_SRC elisp
  (use-package multiple-cursors
    :bind (("C-S-c C-S-c" . mc/edit-lines)
           ("C->" . mc/mark-next-like-this)
           ("C-<" . mc/mark-previous-like-this)
           ("C-c C-<" . mc/mark-all-like-this)))

#+END_SRC

* Configure =erc=
As IRC is also just text, I naturally pull it into Emacs.  This should go
without saying.

#+BEGIN_SRC elisp
  (and (load-library "erc-highlight-nicknames")
       (add-to-list 'erc-modules 'highlight-nicknames)
       (erc-update-modules))
  (setf erc-nick "schweers")
  (add-hook 'erc-mode-hook
            (lambda ()
              (auto-fill-mode -1)
              (show-paren-mode nil)))
#+END_SRC

* Install and configure =ace-link=
I installed this quite a while back.  It is really nice, but sadly I’ve
forgotten how to use it because I hardly need it.

#+BEGIN_SRC elisp
  (use-package ace-link
    :config
    (ace-link-setup-default))
#+END_SRC

* Install and configure =browse-kill-ring=
This extension alone is a good reason to switch to Emacs.  No matter where one
is coming from!  This gives me access to everything I have ever killed/cut in
the current Emacs session.  Also, its searchable!  Helm provides something
similar, but I slightly prefer =browse-kill-ring= to helms alternative.

C-y works the same as ever.  If followed by M-y it also behaves as vanilla
Emacs.  If M-y was not preceded by C-y, a new window is created (if needed) to
display the contents of the kill ring.

#+BEGIN_SRC elisp
  (use-package browse-kill-ring
    ;; (:post-install
    ;;  (browse-kill-ring-default-keybindings))
    :bind (("C-M-y" . browse-kill-ring)))
#+END_SRC
* Install =js2-mode=
Install =js2-mode=, as it is allegedly better than the js mode which comes with
emacs, and because swank-js needs it.  Note that this probably has to be
installed before slime can add it to its contribs.

#+BEGIN_SRC elisp
  (use-package js2-mode
    :mode "\\.js")
#+END_SRC
* Install nodejs-repl
#+BEGIN_SRC elisp
  ;; (pc nodejs-repl
  ;;   (:bind (("C-x C-e" . nodejs-repl-send-last-sexp)
  ;;           ("C-c C-r" . nodejs-repl-send-region)
  ;;           ("C-c C-l" . nodejs-repl-load-file)
  ;;           ("C-c C-z" . nodejs-repl-switch-to-repl))))
#+END_SRC
* Install and configure =SLIME=
SLIME makes interaction with a Common Lisp process almost as seamless as
interacting with the elisp VM underlying Emacs!

#+BEGIN_SRC elisp
  ;; (pc ac-slime)

  (use-package slime
    :commands slime
    :config
    (require 'slime-autoloads)
    (cond ((eq system-type 'windows-nt)
           (setf inferior-lisp-program "sbcl --dynamic-space-size 2048"))
          ((eq system-type 'gnu/linux)
           (setf inferior-lisp-program "sbcl --dynamic-space-size 20000")))
    (slime-setup '(slime-repl slime-scratch slime-fancy slime-tramp))
    (add-to-list 'slime-filename-translations
                 (slime-create-filename-translator
                  :machine-instance "routingimport"
                  :remote-host "routingimport.alpserver.de"
                  :username "nsc"))
    (defun helm-slime-repl-history ()
      "helm for SLIME repl history."
      (interactive)
      (let* ((end (point))
             (beg (save-excursion (move-beginning-of-line 1) (point)))
             (input (buffer-substring beg end))
             ;; slime-repl-input-history is buffer local, so we must not be in a
             ;; helm buffer when accessing the variable.
             (history slime-repl-input-history)
             flag-empty)
        (when (eq beg end)
          (insert " ")
          (setq flag-empty t)
          (setq end (point)))
        (unwind-protect
            (with-helm-show-completion beg end
                                       (helm :sources (helm-build-sync-source "SLIME repl history"
                                                        :candidates history
                                                        :action (lambda (candidate)
                                                                  (slime-repl-kill-input)
                                                                  (insert candidate)))
                                             ;; (helm-make-source "Eshell history"
                                             ;;     'helm-eshell-history-source)
                                             :buffer "*helm SLIME repl history*"
                                             :resume 'noresume
                                             :input input))
          (when (and flag-empty
                     (looking-back " " (1- (point))))
            (delete-char -1)))))
    (define-key slime-repl-mode-map (kbd "M-r") 'helm-slime-repl-history)

    ;; (setf inferior-lisp-program "/home/schweers/code/src/ccl/lx86cl64")
    ;; (add-to-list 'slime-contribs 'slime-fancy)

    ;; (require 'ac-slime)
    ;; (add-hook 'slime-mode-hook 'set-up-slime-ac)
    ;; (add-hook 'slime-repl-mode-hook 'set-up-slime-ac)
    ;; (add-to-list 'ac-modes 'slime-repl-mode)
    )
#+END_SRC

* Configure Scheme
** Install and configure =geiser=
  :PROPERTIES:
  :header-args: :tangle no
  :END:
Geiser is to scheme what SLIME is to Common Lisp.  Sadly it needs some more
love.  Also it behaves a little strangely due to the fact that it supports more
than one backend.

#+BEGIN_SRC elisp
  (pc geiser
    (:post-install
     ;; (setf geiser-racket-binary "/usr/local/bin/racket")
     ))
#+END_SRC

** Configure =inferior-scheme-mode=
When lispy is active in =inferior-scheme-mode=, RET is by default bound to a
lispy command.  Normally this is all well and good, but not for comint derived
modes.  This is why the following binding is needed.

#+BEGIN_SRC elisp
  ;; (defadvice lispy-newline-and-indent-plain (around fix-inferior-scheme (orig))
  ;;   (if (eq major-mode 'inferior-scheme-mode)
  ;;       (call-interactively #'comint-send-input)
  ;;     (funcall orig)))

  (defun schweers/fix-scheme-lispy-RET ()
    (define-key inferior-scheme-mode-map (kbd "<S-return>") 'comint-send-input))

  (add-hook 'inferior-scheme-mode-hook
            #'schweers/fix-scheme-lispy-RET)
#+END_SRC

#+BEGIN_SRC elisp
  (add-hook 'inferior-scheme-mode-hook
            (lambda () (define-key lispy-mode-map (kbd "RET") nil)))
#+END_SRC

** Fix some indentation
Scheme mode looks into the property lists of symbols to find out how to indent
them.  It seems that a number simply tells it by how much to indent, while a
function can do more elaborate stuff.

#+BEGIN_SRC elisp
  (put 'match-let 'scheme-indent-function 'scheme-let-indent)
  (put 'match-let* 'scheme-indent-function 'scheme-let-indent)
  (put 'match 'scheme-indent-function 1)
  (put '^ 'scheme-indent-function 1)
  (put 'when 'scheme-indent-function 1)
  (put 'unless 'scheme-indent-function 1)
  (put 'match-lambda* 'scheme-indent-function 0)
  (put 'receive 'scheme-indent-function 2)
  (put 'let/cc 'scheme-indent-function 1)
  (put 'guard 'scheme-indent-function 1)
#+END_SRC
* Install and configure =expand-region=
This is a package I hardly use, although it seems to be really cool.  Maybe I
don’t use it because I already have lispy.

#+BEGIN_SRC elisp
  (use-package expand-region
    :bind
    (("C-=" . er/expand-region)))
#+END_SRC

* Activate eldoc on lisp buffers
This only works on elisp, so its not activated for all lisps I use.

#+BEGIN_SRC elisp
  (add-hook 'lisp-interaction-mode-hook (-partial 'eldoc-mode))
  (add-hook 'emacs-lisp-mode-hook (-partial 'eldoc-mode))
#+END_SRC

* Install and configure =diminish=
Diminish is used to prevent the mode line from becoming too cluttered.  Sadly I
have not yet gotten it to work for =emacs-lisp-mode=.

#+BEGIN_SRC elisp
  (use-package diminish
    :config
    (diminish 'emacs-lisp-mode "EL")
    (diminish 'lisp-interaction-mode "LIM")
    (diminish 'auto-revert-mode))
#+END_SRC

* Install and configure =helm=
This is a package which redefines completion.  When I first used Emacs, I was in
awe at how awesome the completion was.  Then I discovered Ido and was stunned
again.  Then I discovered helm and was stunned yet once more.  It really is that
awesome, even though it is a bit intrusive.

#+BEGIN_SRC elisp
  (use-package helm
    :config
    (require 'helm-config)
    (setf helm-man-or-woman-function 'woman
          helm-man-or-woman-function 'Man-getpage-in-background
          ;; setting helm-buffer-max-length to nil means that helm will use the
          ;; length of the longest buffer name.
          helm-buffer-max-length nil)
    (helm-mode 1)
    (provide 'setup-helm)
    (diminish 'helm-mode)
    :bind
    (("M-x" . helm-M-x)
     ("M-y" . helm-show-kill-ring)
     ("C-x C-f" . helm-find-files)
     ("C-x b" . helm-mini)))
#+END_SRC

* Install =helm-swoop=
I came across this today (<2017-04-21 Fri>) and just had to try it out.  Some
docs can be found here: https://github.com/ShingoFukuyama/helm-swoop
#+BEGIN_SRC elisp
  (use-package helm-swoop
    :bind (("M-s M-s" . helm-swoop)
           ("M-s M-m" . helm-multi-swoop)))
#+END_SRC

* Install and configure ggtags
  :PROPERTIES:
  :header-args: :tangle no
  :END:

#+BEGIN_SRC elisp
  (use-package ggtags
    :config
    (add-hook 'c-mode-common-hook
              (lambda ()
                (when (derived-mode-p 'csmode 'c++-mode 'java-mode)
                  (ggtags-mode 1)))))
#+END_SRC

* Install and configure =helm-gtags= for C(++) development
  :PROPERTIES:
  :header-args: :tangle no
  :END:

Helm can apparently be really cool for C++ (well, as cool as C++ can get) if
used with GNU global.  Here we set it up to do so.

#+BEGIN_SRC elisp
  (use-package helm-gtags
    :config
    (setf helm-gtags-ignore-case t
          helm-gtags-auto-update t
          helm-gtags-use-input-at-cursor t
          helm-gtags-pulse-at-cursor t
          helm-gtags-prefix-key "\C-cg"
          helm-gtags-suggested-key-mapping t)

    (require 'helm-gtags)
    ;; Enable helm-gtags-mode
    (add-hook 'dired-mode-hook 'helm-gtags-mode)
    (add-hook 'eshell-mode-hook 'helm-gtags-mode)
    (add-hook 'c-mode-hook 'helm-gtags-mode)
    (add-hook 'c++-mode-hook 'helm-gtags-mode)
    (add-hook 'asm-mode-hook 'helm-gtags-mode)

    (define-key helm-gtags-mode-map (kbd "C-c g a") 'helm-gtags-tags-in-this-function)
    (define-key helm-gtags-mode-map (kbd "C-j") 'helm-gtags-select)
    (define-key helm-gtags-mode-map (kbd "M-.") 'helm-gtags-dwim)
    (define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack)
    (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
    (define-key helm-gtags-mode-map (kbd "C-c >")
      'helm-gtags-next-history))
#+END_SRC
* Make it easy to look something up in the CL Hyperspec
The hyperspec it /the/ definitive resource on Common Lisp, so I want quick
access to it.

#+BEGIN_SRC elisp
  (if (file-exists-p (expand-file-name "quicklisp/clhs-use-local.el"
                                       (getenv "HOME")))
      (progn (load (expand-file-name "quicklisp/clhs-use-local.el" (getenv "HOME")))

             (defun schweers/browse-with-w3m (url &rest _args)
               (other-window 1)
               (w3m url t)
               (other-window -1))

             (defun schweers/browse-local-hyperspec ()
               (let ((browse-url-browser-function 'schweers/browse-with-w3m))
                 (if (<= (length (window-list)) 1)
                     (split-window-sensibly))
                 (funcall 'slime-documentation-lookup)))

             (defun schweers/browse-hyperspec-in-w3m-other-window ()
               (interactive)
               "Open the local hyperspec for the symbol at point in w3m in the
  other window."
               (schweers/browse-local-hyperspec))

             (define-key help-map (kbd "h")
               'schweers/browse-hyperspec-in-w3m-other-window))
    (warn "CLHS is not installed! (use (ql:quickload \"clhs\") to install and get
               further instructions."))
#+END_SRC

* Load =forth-mode=
  :PROPERTIES:
  :header-args: :tangle no
  :END:
In case I want to use forth again.

#+BEGIN_SRC elisp
  (use-package forth-mode
    :config
    (defun forth-eval-defun ()
      (interactive)
      (save-mark-and-excursion
       (mark-defun)
       (forth-eval-region (min (point) (mark))
                          (max (point) (mark)))))
    :bind (:map forth-mode-map
                ("C-M-x" . forth-eval-defun))
    :mode "\\.fs\\'")
#+END_SRC

* Install and configure =undo-tree=
This alone is also a reason to switch to Emacs.  It takes undo to a whole new
level.

#+BEGIN_SRC elisp
  (use-package undo-tree
    :config
    (global-undo-tree-mode 1)
    :diminish undo-tree-mode)
#+END_SRC

* Install and configure Emacs for clojure

** Install =clojure-mode=

#+BEGIN_SRC elisp
  (use-package clojure-mode
    :commands clojure-mode)
#+END_SRC

** Install =cider=
Cider is like SLIME and geiser, but for clojure.

#+BEGIN_SRC elisp
  (use-package cider
    :commands cider)
#+END_SRC

* Install and configure =projectile=
Sadly I don’t use this that much.  It can be used together with helm.
Projectile can figure out where a project is by looking for typical files and
directories (like .git).

#+BEGIN_SRC elisp
  (use-package projectile
    :config
    (projectile-mode))

  (use-package helm-projectile
    :config
    (define-key projectile-mode-map (kbd "s-h") 'helm-projectile))
#+END_SRC

* Install and configure =helm-ag=
  :PROPERTIES:
  :header-args: :tangle no
  :END:
I’ll defer loading this until I know what I want it for and how to delay it.
#+BEGIN_SRC elisp
  (use-package helm-ag)
#+END_SRC
* Make parentheses less prominent
I use =global-paren-face-mode= to make parentheses stand out a little less.

#+BEGIN_SRC elisp
  (use-package paren-face
    :config
    (global-paren-face-mode 1))
#+END_SRC

* Install =w3m=
I use this to browse the hyperspec.  Don't require it, as it will fail on
Windows.

#+BEGIN_SRC elisp
  (condition-case e
      (use-package w3m
        :commands w3m)
    (error
     (warn "installing w3m failed: %s" (error-message-string e))))
#+END_SRC

* Install and configure =elfeed=
Elfeed is an RSS reader modeled on notmuch, i.e. it uses tags and searches.  It
works much better than RSS in gnus.

The feeds can also be entered here.

#+BEGIN_SRC elisp
  (use-package elfeed
    :commands elfeed
    :config
    (setf elfeed-feeds
          '(("http://endlessparentheses.com/atom.xml"
             endlessparentheses blog emacs)
            ("http://oremacs.com/atom.xml" oremacs blog emacs)
            ("http://emacsredux.com/atom.xml" emacsredux blog emacs)
            ("http://bitstacker.soup.io/rss" bitstacker)
            ("http://www.copenhagenize.com/feeds/posts/default"
             copenhagenize bike blog)
            ("https://feeds.feedburner.com/blogspot/rkEL" der-postillon)
            ("https://www.eine-zeitung.net/feed/" eine-zeitung)
            ("https://feeds2.feedburner.com/gbo-zitate" gbo)
            ("http://ibash.de/neueste-zitate.xml" ibash)
            ("http://itstartedwithafight.de/feed/" itstartedwithafight bike blog)
            ("http://irreal.org/blog/?feed=rss2" irreal blog emacs)
            ("https://www.heise.de/developer/rss/news-atom.xml" heise-developer
             heise)
            ("https://www.heise.de/netze/rss/netze-atom.xml" heise-netze heise)
            ("https://www.heise.de/security/news/news-atom.xml" heise-security
             heise)
            ("https://www.heise.de/tp/news-atom.xml" telepolis heise)
            ("http://cre.fm/feed/opus/" cre podcast)
            ("https://xkcd.com/rss.xml" xkcd webcomic)
            ("https://www.tagesschau.de/xml/rss2" tagesschau news)
            ("https://wingolog.org/feed/atom" wingolog blog)
            ("http://howardism.org/index.xml" howardism blog emacs)
            ("http://nullprogram.com/feed/" nullprogram blog emacs)
            ("http://busy-streets.de/feed/" blog busy-streets bike)
            ("http://cestlaz.github.io/rss.xml" blog emacs cestlaz zamansky)
            ("https://www.archlinux.org/feeds/news/" blog archlinux)
            ("http://pragmaticemacs.com/feed/" blog emacs pragmaticemacs)
            ("http://feed.dilbert.com/dilbert/daily_strip" dilbert webcomic))))
#+END_SRC

** Make elfeed be in emacs state by default
   :PROPERTIES:
   :header-args: :tangle no
   :END:
Elfeed binds its keys not expecting evil to be present.  For this reason, elfeed
should start in emacs state.  In the future it might be nice to devise a good
set of evil bindings, but for now, emacs mode should suffice.

#+BEGIN_SRC elisp
  (add-hook 'elfeed-search-mode-hook
            (lambda ()
              (evil-set-initial-state 'elfeed-search-mode 'emacs)))
  ;; (evil-set-initial-state 'elfeed-show-mode 'emacs)
#+END_SRC
* Install and configure =avy=
Avy can be used to jump to a position which is visible in the current window.

#+BEGIN_SRC elisp
  (use-package avy
    ;; (:post-install
    ;;  (global-set-key
    ;;   (kbd "M-\"")
    ;;   (defhydra hydra-avy (:color teal)
    ;;     "avy-goto"
    ;;     ("c" avy-goto-char "char")
    ;;     ("2" avy-goto-char-2 "char-2")
    ;;     ("g" avy-goto-line "line")
    ;;     ("w" avy-goto-word-1 "word"))))
    :config
    (defhydra hydra-avy (:color teal)
      "avy-goto"
      ("c" avy-goto-char "char")
      ("2" avy-goto-char-2 "char-2")
      ("g" avy-goto-line "line")
      ("w" avy-goto-word-1 "word"))
    :bind (("M-\"" . hydra-avy/body)))

#+END_SRC

* Install and configure =swiper=
  :PROPERTIES:
  :header-args: :tangle no
  :END:
#+BEGIN_SRC elisp
  (pc swiper
    (:bind
     (("C-s" . swiper))))
#+END_SRC
* Install and configure haskell packages
At the very least, we need =haskell-mode=, otherwise we can’t properly edit
files.

#+BEGIN_SRC elisp
  (use-package haskell-mode
    :mode "\\.hs"
    :mode "\\.lhs")
#+END_SRC

I also want to try flycheck for haskell:

#+BEGIN_SRC elisp
  (use-package flycheck-haskell
    :after haskell-mode)
#+END_SRC
* Install =lua-mode=
Lua mode is needed for computercraft.

Luckily, files in a computer inside of computercraft also exist in the
filesystem outside of minecraft/feed the beast.

#+BEGIN_SRC elisp
  (use-package lua-mode
    :mode "\\.lua")
#+END_SRC
* Install and require =tramp-term=
Apparently, tramp-term integrates a remote ssh session with TRAMP.
#+BEGIN_SRC elisp
  (use-package tramp-term)
#+END_SRC
* Install =fuel= in order to experiment with factor
  :PROPERTIES:
  :header-args: :tangle no
  :END:
#+BEGIN_SRC elisp
  (pc fuel
    (:require nil)
    (setf fuel-listener-factor-binary (expand-file-name "opt/factor/factor"
                                                        (getenv "HOME"))
          fuel-listener-factor-image (expand-file-name "opt/factor/factor.image"
                                                       (getenv "HOME"))))
#+END_SRC
* Install and configure yasnippet for C++ mode
  :PROPERTIES:
  :header-args: :tangle no
  :END:
#+BEGIN_SRC elisp
  (pc yasnippet
    (:postinstall
     (add-hook 'c++-mode-hook #'yas-minor-mode)))
#+END_SRC
* Try some C++ stuff out
  :PROPERTIES:
  :header-args: :tangle no
  :END:
Maybe this will work for C++

#+BEGIN_SRC elisp
  (pc auto-complete-c-headers)

  (defun my:ac-c-header-init ()
    (require 'auto-complete-c-headers)
    (add-to-list 'ac-sources 'ac-source-c-headers)
    ;; (add-to-list 'achead:include-directories '"/Applications/Xcode.app/Contents/Developer/usr/llvm-gcc-4.2/lib/gcc/i686-apple-darwin11/4.2.1/include")
    )
  ; now let's call this function from c/c++ hooks
  (add-hook 'c++-mode-hook 'my:ac-c-header-init)
  (add-hook 'c-mode-hook 'my:ac-c-header-init)

  ; turn on Semantic
  (semantic-mode 1)
  ; let's define a function which adds semantic as a suggestion backend to auto complete
  ; and hook this function to c-mode-common-hook
  (defun my:add-semantic-to-autocomplete()
    (add-to-list 'ac-sources 'ac-source-semantic))

  (add-hook 'c-mode-common-hook 'my:add-semantic-to-autocomplete)
  ; turn on ede mode
  (global-ede-mode 1)
  ; create a project for our program.
  (ede-cpp-root-project "rtree" :file "~/code/pick/rtree/rtree.cpp"
                        :include-path '("~/code/third_party/boost_1_63_0/"))
  ; you can use system-include-path for setting up the system header file locations.
  ; turn on automatic reparsing of open buffers in semantic
  (global-semantic-idle-scheduler-mode 1)

#+END_SRC
* Pimp =occur= a little
Unlike occur, rgrep binds n and p to switch to the next and previous match by
default.

#+BEGIN_SRC elisp
  (defun schweers/occur-next-match ()
    (interactive)
    (occur-next)
    (occur-mode-display-occurrence))

  (defun schweers/occur-prev-match ()
    (interactive)
    (occur-prev)
    (occur-mode-display-occurrence))

  (define-key occur-mode-map (kbd "n") #'schweers/occur-next-match)
  (define-key occur-mode-map (kbd "p") #'schweers/occur-prev-match)

  (defadvice occur (after schweers/occur-select-occur (regexp &optional nlines))
    (select-window (get-buffer-window "*Occur*")))
#+END_SRC
* Install =cmake-mode=
  #+BEGIN_SRC elisp
    (use-package cmake-mode
      :commands cmake-mode)
  #+END_SRC
* Install =protobuf-mode=
  #+BEGIN_SRC elisp
    (use-package protobuf-mode
      :mode "\\.pbf")
  #+END_SRC
* Install go-mode and assorted packages
  :PROPERTIES:
  :header-args: :tangle no
  :END:
I want to try out golang, I’ll probably not use it, but hey.

#+BEGIN_SRC elisp
  (pc go-mode
    (:post-install
     (add-hook 'go-mode-hook
               (lambda ()
                 (add-hook 'before-save-hook 'gofmt-before-save)
                 (setf tab-width 2)
                 (setf indent-tabs-mode 1)))))
  (pc go-eldoc)
  (pc go-scratch)
#+END_SRC

* Install rust tools
** Install =rust-mode=
This one is obvious, isn’t it?
#+BEGIN_SRC elisp
  (use-package rust-mode
    :mode "\\.rs")
#+END_SRC
** Install =cargo=
This one is for editing cargo files
#+BEGIN_SRC elisp
  (use-package cargo
    :mode "Cargo.toml")
#+END_SRC
** Install =flycheck-rust=
#+BEGIN_SRC elisp
  (use-package flycheck-rust
    :after rust-mode)
#+END_SRC
* Install and configure dumb-jump
This is supposed to give me pleasant go to definition for several languages
without configuration.  I especially need this for C(++).  Lisp can do this way
better anyway be virtue of having a running image.
#+BEGIN_SRC elisp
  (use-package dumb-jump
    :config (dumb-jump-mode)
    :bind (("M-." . dumb-jump-go)
           ("M-," . dumb-jump-back)
           ("C-M-g" . dumb-jump-go-other-window)))
#+END_SRC
* Install =smartscan=
  I [[file:c:/Users/schweers/Nextcloud/org/notes.org::*Look%20into%20smart%20scan,%20or%20write%20an%20alternative][wanted to do this for ages]], let’s see how it goes.

  #+BEGIN_SRC elisp
    (use-package smartscan
      :demand t
      :config
      (smartscan-mode 1))
  #+END_SRC
* Use chromium (or chromium-browser?)
  :PROPERTIES:
  :header-args: :tangle no
  :END:
#+BEGIN_SRC elisp
  (setf browse-url-browser-function #'browse-url-chromium
        browse-url-generic-program "chromium")
#+END_SRC
* Configure helm and eshell
#+BEGIN_SRC elisp
  (add-hook 'eshell-mode-hook
            (lambda ()
              (add-to-list 'eshell-visual-commands "htop")
              (eshell-cmpl-initialize)
              (define-key eshell-mode-map [remap eshell-pcomplete]
                'helm-esh-pcomplete)
              (define-key eshell-mode-map (kbd "M-p") 'helm-eshell-history)))

  (defun pcomplete/sudo ()
    (let ((prec (pcomplete-arg 'last -1)))
      (cond ((string= "sudo" prec)
             (while (pcomplete-here*
                     (funcall pcomplete-command-completion-function)
                     (pcomplete-arg 'last) t))))))

  (defalias 'open 'find-file)
  (defalias 'openo 'find-file-other-window)

#+END_SRC
* Install =pdf-tools=
#+BEGIN_SRC elisp
  (use-package pdf-tools
    :config (pdf-tools-install))

#+END_SRC
* Do some SQL setup
#+BEGIN_SRC elisp
  (use-package sql-indent
    :after (sql))

  (use-package sqlup-mode
    :after (sql)
    :config
    (add-hook 'sql-mode-hook
              (lambda ()
                (sqlup-mode 1))))
#+END_SRC
* Define a minor mode for keybindings
I use a separate minor mode which does nothing but bind keys.  This has the
advantage that other modes cannot quite as easily overwrite my keybindings.

#+BEGIN_SRC elisp
  (defvar *schweers-bindings* (make-sparse-keymap))

  (define-key *schweers-bindings* (kbd "C-w") 'backward-kill-word)
  (define-key *schweers-bindings* (kbd "C-M-w") 'kill-region)
  (define-key *schweers-bindings* (kbd "C-M-S-w") 'append-next-kill)

  (define-key *schweers-bindings* (kbd "C-S-e") 'eshell)

  (define-key *schweers-bindings* (kbd "s-e") 'eshell)
  ;; (define-key *schweers-bindings* (kbd "<f1>") 'help-command)

  (defun use-arrows! ()
    "Complain to the user about not having used the arrow keys.

  As someone who uses a proper keyboard layout, the arrow keys are a viable option
    (unless using guake *grr*)."
    (interactive)
    (error "Use the arrow keys, that’s what you have a proper layout for!"))

  ;; Use the arrow keys on the keyboard, damnit! That’s what they’re there for!
  ;; (define-key *schweers-bindings* (kbd "C-f") #'use-arrows!)
  ;; (define-key *schweers-bindings* (kbd "C-b") #'use-arrows!)
  ;; (define-key *schweers-bindings* (kbd "C-n") #'use-arrows!)
  ;; (define-key *schweers-bindings* (kbd "C-p") #'use-arrows!)

  (define-key *schweers-bindings*
    (kbd "M-t")
    (let ((hydra-transpose/custom-prefix-arg nil))
      (defhydra hydra-transpose-backward
        (:pre (if (or (null hydra-transpose/custom-prefix-arg)
                      (>= hydra-transpose/custom-prefix-arg 0))
                  (setq hydra-transpose/custom-prefix-arg -1))
              :color pink)
        "transpose backward"
        ("d" hydra-transpose/body "toggle direction" :exit t)
        ("f" hydra-transpose/body "forward mode" :exit t)
        ("b" hydra-transpose-backward/body "backward mode" :exit t)
        ("u" (lambda (arg)
               (interactive "nPrefix: ")
               (setq hydra-transpose/custom-prefix-arg (- (abs arg)))
               (message "prefix: %s" hydra-transpose/custom-prefix-arg))
         "prefix")
        ("r" (lambda ()
               (interactive)
               (setq hydra-transpose/custom-prefix-arg -1))
         "reset prefix")
        ("c" (lambda ()
               (interactive)
               (let ((current-prefix-arg
                      hydra-transpose/custom-prefix-arg))
                 (call-interactively #'transpose-chars)
                 (call-interactively #'forward-char)))
         "chars")
        ("l" (lambda ()
               (interactive)
               (let ((current-prefix-arg
                      hydra-transpose/custom-prefix-arg))
                 (call-interactively #'transpose-lines)
                 (call-interactively #'forward-line))
               (setq hydra-transpose/custom-prefix-arg -1))
         "lines")
        ("w" (lambda ()
               (interactive)
               (message "current-prefix: %s" hydra-transpose/custom-prefix-arg)
               (let ((current-prefix-arg
                      hydra-transpose/custom-prefix-arg))
                 (call-interactively #'transpose-words)
                 (call-interactively #'forward-word))
               (setq hydra-transpose/custom-prefix-arg -1))
         "words")
        ("s" (lambda ()
               (interactive)
               (let ((current-prefix-arg
                      hydra-transpose/custom-prefix-arg))
                 (call-interactively #'transpose-sexps)
                 (call-interactively #'forward-sexp))
               (setq hydra-transpose/custom-prefix-arg -1))
         "sexps")
        ("p" (lambda ()
               (interactive)
               (let ((current-prefix-arg
                      hydra-transpose/custom-prefix-arg))
                 (call-interactively #'transpose-paragraphs)
                 (call-interactively #'forward-paragraph))
               (setq hydra-transpose/custom-prefix-arg -1))
         "paragraphs")
        ("S" (lambda ()
               (interactive)
               (let ((current-prefix-arg
                      hydra-transpose/custom-prefix-arg))
                 (call-interactively #'transpose-sentences)
                 (call-interactively #'forward-sentence))
               (setq hydra-transpose/custom-prefix-arg -1))
         "sentences")
        ("e" org-transpose-element "Org mode elements")
        ("q" nil "quit"))

      (defhydra hydra-transpose
        (:pre (if (and (not (null hydra-transpose/custom-prefix-arg))
                       (< hydra-transpose/custom-prefix-arg 0))
                  (setq hydra-transpose/custom-prefix-arg nil))
              :color pink)
        "transpose"
        ("d" hydra-transpose-backward/body "toggle direction" :exit t)
        ("f" hydra-transpose/body "forward mode" :exit t)
        ("b" hydra-transpose-backward/body "backward mode" :exit t)
        ("u" (lambda (arg)
               (interactive "nPrefix: ")
               (setq hydra-transpose/custom-prefix-arg arg))
         "prefix")
        ("r" (lambda ()
               (interactive)
               (setq hydra-transpose/custom-prefix-arg nil))
         "reset prefix")
        ("c" (lambda ()
               (interactive)
               (let ((current-prefix-arg
                      hydra-transpose/custom-prefix-arg))
                 (call-interactively #'transpose-chars))
               (setq hydra-transpose/custom-prefix-arg nil))
         "chars")
        ("l" (lambda ()
               (interactive)
               (let ((current-prefix-arg
                      hydra-transpose/custom-prefix-arg))
                 (call-interactively #'transpose-lines))
               (setq hydra-transpose/custom-prefix-arg nil))
         "lines")
        ("w" (lambda ()
               (interactive)
               (let ((current-prefix-arg
                      hydra-transpose/custom-prefix-arg))
                 (call-interactively #'transpose-words))
               (setq hydra-transpose/custom-prefix-arg nil))
         "words")
        ("s" (lambda ()
               (interactive)
               (let ((current-prefix-arg
                      hydra-transpose/custom-prefix-arg))
                 (call-interactively #'transpose-sexps))
               (setq hydra-transpose/custom-prefix-arg nil))
         "sexps")
        ("p" (lambda ()
               (interactive)
               (let ((current-prefix-arg
                      hydra-transpose/custom-prefix-arg))
                 (call-interactively #'transpose-paragraphs))
               (setq hydra-transpose/custom-prefix-arg nil))
         "paragraphs")
        ("S" (lambda ()
               (interactive)
               (let ((current-prefix-arg
                      hydra-transpose/custom-prefix-arg))
                 (call-interactively #'transpose-sentences)))
         "sentences")
        ("e" org-transpose-element "Org mode elements")
        ("q" nil "quit"))))

  (define-key *schweers-bindings*
    (kbd "C-x -")
    (defhydra hydra-resize-window ()
      "resize"
      ("l" enlarge-window "taller")
      ("r" shrink-window "shorter")
      ("n" shrink-window-horizontally "narrower")
      ("s" enlarge-window-horizontally "wider")
      ("-" shrink-window-if-larger-than-buffer "short (aggressive)")
      ("+" balance-windows "balance")
      ("t" toggle-frame-split "frame split")
      ("q" nil "quit")))

  (define-key *schweers-bindings*
    (kbd "C-x t")
    (defhydra hydra-toggle (:color teal)
      "toggle"
      ("c" column-number-mode "column number mode")
      ("d" toggle-debug-on-error "debug on error")
      ("e" toggle-debug-on-error "debug on error")
      ("f" auto-fill-mode "auto-fill mode")
      ("t" toggle-truncate-lines "truncate lines")
      ("Q" toggle-debug-on-quit "debug on quit")
      ("r" dired-toggle-read-only "dired: read-only")
      ("w" whitespace-mode "whitespace mode")
      ("l" org-toggle-link-display "Org: toggle link display")
      ("q" nil "quit")))

  (define-key *schweers-bindings* (kbd "M-o") 'occur)
  (define-key *schweers-bindings* (kbd "C-x C-b") 'ibuffer-other-window)
  (define-key *schweers-bindings* (kbd "M-j") 'eval-print-last-sexp)
  (define-key *schweers-bindings* (kbd "C-x C-SPC") 'helm-all-mark-rings)
  (define-key *schweers-bindings* (kbd "C-c C-j") 'helm-mark-ring)
  (define-key *schweers-bindings* (kbd "C-M-l") 'misc/mark-line)

  (define-key *schweers-bindings* (kbd "<f6>") 'schweers/increase-font)
  (define-key *schweers-bindings* (kbd "<f7>") 'schweers/decrease-font)

  (define-key *schweers-bindings* (kbd "C-x k") 'schweers/kill-buffer)

  (define-key *schweers-bindings* (kbd "C-<down>") 'scroll-up-line)
  (define-key *schweers-bindings* (kbd "C-<up>") 'scroll-down-line)

  (global-set-key (kbd "C-S-s") 'misc/switch-to-scratch)

  (global-set-key (kbd "C-c L") 'org-insert-link-global)
  (global-set-key (kbd "C-c o") 'org-open-at-point-global)

  ;; (define-key *schweers-bindings* (kbd "C-c M-b") 'bury-buffer)

  (define-minor-mode schweers-bindings-mode
    "This minor mode binds my own keybindings."
    :keymap *schweers-bindings*)

  (define-globalized-minor-mode schweers-global-bindings-mode
    schweers-bindings-mode schweers-bindings-mode)

  ;;; Turn it on, already
  (schweers-global-bindings-mode)

  ;;; As some modes—I’m looking at you, wl-draft-mode—think it’s totally OK to
  ;;; rebind my keys, I’ll put them into the overriding keymap instead.

  ;; (defun schweers/set-bindings-in-broken-modes ()
  ;;   (cl-flet
  ;;       ((find-my-bindings
  ;;         (e)
  ;;         (eq (car e) 'schweers-bindings-mode)))
  ;;     (setq
  ;;      minor-mode-overriding-map-alist
  ;;      (-filter #'find-my-bindings minor-mode-map-alist))))

  ;; minor-mode-overriding-map-alist
  ;; minor-mode-map-alist
  ;; (add-to-list 'minor-mode-map-alist (car minor-mode-overriding-map-alist))

  ;; (add-hook 'wl-draft-mode-hook #'schweers/set-bindings-in-broken-modes)

  ;; (setq  wl-draft-mode-hook nil)

#+END_SRC
* Start Emacs in server mode
If Emacs is not already running as a server, start the server component.  This
way I only need to start Emacs once and can use emacsclient from then on.

#+BEGIN_SRC elisp
  (require 'server)
  (unless (server-running-p)
    (server-start))
#+END_SRC
** Install and start =edit-server=
Emacs can also provide an HTTP(?) edit server, so chromium can use it with “Edit
with Emacs”.

#+BEGIN_SRC elisp
  (use-package edit-server
    :config
    (edit-server-start))
#+END_SRC
* Boot up with our literate config
Using literate programming with Org Mode to configure Emacs is fine, but it has
a small problem: loading can be really slow.  To address this, the following has
to be done:

- Tangle the org file if .org is newer than .el, or no .el exists
- Compile .el if it it newer than .elc, or no .elc exists

The following function should do exactly that.

This code block has to be tangled manually.  Should it ever be changed, it must
be added to git!  Otherwise Emacs may not be able to boot!

#+BEGIN_SRC elisp :tangle bootstrap.el
  ;; NOTE: THIS FILE WAS TANGLED FROM literate-init.org.  DO NOT CHANGE THIS FILE
  ;; DIRECTLY!

  ;; I need a macro which abstracts some checks:

  ;; If a file is missing, or is newer than some other file, I want to perform an
  ;; action.  Said action should rectify the previous check.  If the check at the
  ;; beginning does not hold, the supplied action must be performed.  If the same
  ;; check does not hold /after/ the action is performed, an error shall be
  ;; thrown.

  ;; Example usage:

  ;; (with-postcond (or (not (file-exists-p el-name))
  ;;                    (time-less-p (nth 5 (file-attributes el-name))
  ;;                                 (nth 5 (file-attributes lit-name))))
  ;;     (signal 'postcondition-error)
  ;;   (org-babel-tangle-file lit-name))

  (require 'org)

  (defmacro ensure (condition error-clause fixup &rest body)
    "Tries to ensure that CONDITION holds.

  This is accomplished by a series of steps.  First, CONDITION is
  checked.  If it holds, the form returns.  If not, body is
  executed.  Then CONDITION is checked again.  If it holds, the form
  returns.  If the check returns nil, or the body signalled any
  error, the fixup function is tried (if non-nil and a function).
  The fixup function is given either the error, or nil if none was
  signalled.

  Then the check is tried again.  If it now holds, the form
  returns.  If not, body is tried once more.  If it signals an
  error again, it is presumed to be non-recoverable by this macro,
  so the error-clause is executed.  If the check does not hold, the
  error-clause is executed.

  As FIXUP must be a function, the form is evaluated exactly once."
    (declare (indent 3))
    (when (or (null condition)
              (null error-clause))
      (error "Postcondition or Error-clause is missing"))
    (let ((f (make-symbol "f"))
          (e (make-symbol "e")))
      `(let ((,f ,fixup))
         (unless ,condition
           (condition-case ,e ,@body
             (error (if ,f (progn
                             (funcall ,f ,e)
                             ,@body)
                      (signal (car ,e) (cdr ,e)))))
           (unless ,condition
             (when ,f
               (funcall ,f nil))
             (unless ,condition
               ,@body
               (unless ,condition
                 ,error-clause)))))))

  ;; To make the aforementioned macro a little more useful for my case, I need
  ;; another function, which serves as a sort of predicate.  It checks whether the
  ;; first given filename exists, then whether the first is newer than the second.

  (defun missing-or-newer? (a b)
    "Checks whether the file A exists.  If so, checks whether file B exists and is
  older than A."
    (or (not (file-exists-p a))
        (and (file-exists-p b)
             (time-less-p
              (nth 5 (file-attributes a))
              (nth 5 (file-attributes b))))))

  (defun load-literate-init ()
    "Tangles, compiles and loads the literate init file."
    (interactive)
    ;; (require 'org)
    (let ((lit-name
           (expand-file-name "literate-init.org" user-emacs-directory))
          (el-name (expand-file-name "literate-init.el" user-emacs-directory))
          (elc-name (expand-file-name "literate-init.elc" user-emacs-directory)))
      (ensure (not (missing-or-newer? el-name lit-name))
          (error "Could not tangle the literal init file")
          nil
        (org-babel-tangle-file lit-name))
      (ensure (not (missing-or-newer? elc-name el-name))
          (error "Could not byte-compile literal init, even after loading it.")
          (lambda (_e)
            (warn "Need to load non-compiled init file")
            (load el-name))
        (byte-compile-file el-name))
      (load elc-name)))
#+END_SRC
